{"instruction": "Explica el concepto de pilas (Stack) con un ejemplo básico en Java utilizando la clase Stack.", "response": "Las pilas siguen el principio LIFO (Last In, First Out). En Java, la clase `Stack` es la implementación clásica.\n\n```java\nimport java.util.Stack;\n\npublic class PilaBasica {\n    public static void main(String[] args) {\n        Stack<String> libros = new Stack<>();\n        libros.push(\"Libro A\");\n        libros.push(\"Libro B\");\n        \n        System.out.println(\"Elemento en la cima: \" + libros.peek()); // Libro B\n        System.out.println(\"Sacando elemento: \" + libros.pop());   // Libro B\n    }\n}```"}
{"instruction": "Explica el concepto de colas (Queue) utilizando LinkedList en Java.", "response": "Las colas siguen el principio FIFO (First In, First Out). `LinkedList` implementa la interfaz `Queue`.\n\n```java\nimport java.util.LinkedList;\nimport java.util.Queue;\n\npublic class ColaBasica {\n    public static void main(String[] args) {\n        Queue<Integer> turno = new LinkedList<>();\n        turno.offer(1);\n        turno.offer(2);\n        \n        System.out.println(\"Atendiendo a: \" + turno.poll()); // 1\n        System.out.println(\"Siguiente: \" + turno.peek());    // 2\n    }\n}```"}
{"instruction": "Explica la diferencia entre Stack y Heap en la memoria de Java con un ejemplo.", "response": "La memoria Stack guarda variables locales y referencias, mientras que el Heap guarda los objetos instanciados.\n\n```java\npublic class Memoria {\n    public static void main(String[] args) {\n        int primitivo = 10; // Guardado en Stack\n        Persona obj = new Persona(\"Ana\"); \n        // 'obj' es una referencia en Stack que apunta a un objeto en Heap\n    }\n}\nclass Persona { String nombre; Persona(String n) { nombre = n; } }```"}
{"instruction": "Explica cómo representar un grafo utilizando listas de adyacencia en Java.", "response": "Una forma eficiente de representar grafos es usando un `Map` donde cada nodo tiene una lista de vecinos.\n\n```java\nimport java.util.*;\n\npublic class GrafoAdyacencia {\n    Map<Integer, List<Integer>> adj = new HashMap<>();\n\n    void agregarArista(int u, int v) {\n        adj.computeIfAbsent(u, k -> new ArrayList<>()).add(v);\n        // Si es no dirigido, agregar también: adj.computeIfAbsent(v, k -> new ArrayList<>()).add(u);\n    }\n}```"}
{"instruction": "Explica la estructura básica de un nodo para un árbol binario en Java.", "response": "Un árbol binario se compone de nodos, donde cada nodo tiene un valor y referencias a sus hijos izquierdo y derecho.\n\n```java\nclass NodoArbol {\n    int valor;\n    NodoArbol izquierdo, derecho;\n\n    public NodoArbol(int valor) {\n        this.valor = valor;\n        this.izquierdo = null;\n        this.derecho = null;\n    }\n}```"}
{"instruction": "Demuestra un recorrido BFS (Anchura) en un grafo en Java.", "response": "El recorrido BFS utiliza una cola para visitar los nodos nivel por nivel.\n\n```java\nimport java.util.*;\n\npublic void bfs(int inicio, Map<Integer, List<Integer>> grafo) {\n    Set<Integer> visitados = new HashSet<>();\n    Queue<Integer> q = new LinkedList<>();\n    q.add(inicio);\n    visitados.add(inicio);\n    \n    while (!q.isEmpty()) {\n        int nodo = q.poll();\n        System.out.print(nodo + \" \");\n        for (int vecino : grafo.getOrDefault(nodo, new ArrayList<>())) {\n            if (!visitados.contains(vecino)) {\n                visitados.add(vecino);\n                q.add(vecino);\n            }\n        }\n    }\n}```"}
{"instruction": "Explica el concepto de recursión calculando el factorial de un número.", "response": "La recursión ocurre cuando un método se llama a sí mismo. El factorial es el ejemplo clásico.\n\n```java\npublic class Factorial {\n    public static int calcular(int n) {\n        if (n <= 1) return 1; // Caso base\n        return n * calcular(n - 1); // Llamada recursiva\n    }\n}```"}
{"instruction": "Explica la complejidad temporal O(n) con un bucle simple.", "response": "O(n) significa que el tiempo de ejecución crece linealmente con el tamaño de la entrada.\n\n```java\npublic void imprimirLista(String[] palabras) {\n    // Se ejecutan 'n' iteraciones\n    for (String palabra : palabras) {\n        System.out.println(palabra);\n    }\n}```"}
{"instruction": "Explica la complejidad temporal O(1) o tiempo constante.", "response": "O(1) implica que la operación tarda lo mismo sin importar el tamaño de los datos.\n\n```java\npublic int obtenerPrimero(int[] numeros) {\n    // Acceso directo al índice, tiempo constante\n    return numeros[0];\n}```"}
{"instruction": "Explica la complejidad O(n^2) con bucles anidados.", "response": "O(n^2) es común en algoritmos con bucles anidados, donde por cada elemento recorres todos los demás.\n\n```java\npublic void imprimirPares(int[] arr) {\n    for (int i = 0; i < arr.length; i++) {\n        for (int j = 0; j < arr.length; j++) {\n            System.out.println(arr[i] + \", \" + arr[j]);\n        }\n    }\n}```"}
{"instruction": "Muestra cómo usar ArrayDeque como una pila (Stack) más eficiente.", "response": "`ArrayDeque` es generalmente más rápido que `Stack` para operaciones LIFO.\n\n```java\nimport java.util.ArrayDeque;\nimport java.util.Deque;\n\npublic class PilaModerna {\n    public static void main(String[] args) {\n        Deque<Integer> pila = new ArrayDeque<>();\n        pila.push(10);\n        pila.push(20);\n        System.out.println(pila.pop()); // Imprime 20\n    }\n}```"}
{"instruction": "Implementa un recorrido In-Order en un árbol binario.", "response": "El recorrido In-Order visita: Izquierda -> Raíz -> Derecha. Es útil para obtener datos ordenados en un BST.\n\n```java\npublic void inOrder(NodoArbol nodo) {\n    if (nodo != null) {\n        inOrder(nodo.izquierdo);\n        System.out.print(nodo.valor + \" \");\n        inOrder(nodo.derecho);\n    }\n}```"}
{"instruction": "Explica la diferencia conceptual entre Interfaz y Clase Abstracta con un ejemplo.", "response": "Una interfaz define *qué* hacer (contrato), una clase abstracta puede definir *cómo* hacer algunas cosas y dejar otras pendientes.\n\n```java\ninterface Volador { void volar(); }\n\nabstract class Ave {\n    void comer() { System.out.println(\"Comiendo alpiste\"); }\n    abstract void sonido();\n}```"}
{"instruction": "Muestra cómo una clase implementa una interfaz en Java.", "response": "Se usa la palabra clave `implements` y se deben sobrescribir todos los métodos abstractos.\n\n```java\ninterface Servicio {\n    void ejecutar();\n}\n\nclass MiServicio implements Servicio {\n    @Override\n    public void ejecutar() {\n        System.out.println(\"Servicio ejecutándose...\");\n    }\n}```"}
{"instruction": "Demuestra el manejo de excepciones con try-catch-finally.", "response": "El bloque `finally` se ejecuta siempre, ocurra o no una excepción, ideal para cerrar recursos.\n\n```java\npublic void dividir(int a, int b) {\n    try {\n        System.out.println(a / b);\n    } catch (ArithmeticException e) {\n        System.out.println(\"No se puede dividir por cero\");\n    } finally {\n        System.out.println(\"Operación finalizada\");\n    }\n}```"}
{"instruction": "Muestra operaciones básicas de agregar y eliminar en una LinkedList.", "response": "`LinkedList` permite agregar/eliminar eficientemente al inicio o final.\n\n```java\nimport java.util.LinkedList;\n\npublic class ListaOperaciones {\n    public static void main(String[] args) {\n        LinkedList<String> lista = new LinkedList<>();\n        lista.addFirst(\"Inicio\");\n        lista.addLast(\"Fin\");\n        lista.removeFirst(); // Elimina \"Inicio\"\n    }\n}```"}
{"instruction": "Implementa manualmente un nodo simple para una lista enlazada.", "response": "En lugar de usar la colección de Java, puedes crear tu propia estructura de nodo.\n\n```java\nclass NodoSimple {\n    int dato;\n    NodoSimple siguiente;\n    \n    public NodoSimple(int d) {\n        dato = d;\n        siguiente = null;\n    }\n}```"}
{"instruction": "Explica el uso de ArrayList como estructura de datos dinámica.", "response": "`ArrayList` es un arreglo redimensionable. Es rápido para acceder por índice `get(i)`.\n\n```java\nimport java.util.ArrayList;\n\npublic class EjemploArrayList {\n    public static void main(String[] args) {\n        ArrayList<String> nombres = new ArrayList<>();\n        nombres.add(\"Java\");\n        nombres.add(\"Python\");\n        System.out.println(nombres.get(0)); // Java\n    }\n}```"}
{"instruction": "Explica el uso de HashSet para almacenar elementos únicos.", "response": "`HashSet` no permite duplicados y no garantiza el orden de los elementos.\n\n```java\nimport java.util.HashSet;\n\npublic class ConjuntoUnico {\n    public static void main(String[] args) {\n        HashSet<Integer> set = new HashSet<>();\n        set.add(1);\n        set.add(1); // Ignorado\n        System.out.println(set.size()); // 1\n    }\n}```"}
{"instruction": "Demuestra el uso de PriorityQueue (Cola de prioridad).", "response": "En una `PriorityQueue`, los elementos salen ordenados naturalmente (o por un comparador), no por orden de llegada.\n\n```java\nimport java.util.PriorityQueue;\n\npublic class ColaPrioridad {\n    public static void main(String[] args) {\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\n        pq.add(30);\n        pq.add(10);\n        pq.add(20);\n        System.out.println(pq.poll()); // 10 (el menor)\n    }\n}```"}
{"instruction": "Explica cómo lanzar una excepción personalizada.", "response": "Puedes usar `throw` para disparar una excepción cuando se cumple una condición de error.\n\n```java\npublic void validarEdad(int edad) {\n    if (edad < 18) {\n        throw new IllegalArgumentException(\"Edad no válida para el registro\");\n    }\n}```"}
{"instruction": "Ordena un arreglo de primitivos usando Arrays.sort().", "response": "Java utiliza una variante de QuickSort (Dual-Pivot) para ordenar primitivos.\n\n```java\nimport java.util.Arrays;\n\npublic class OrdenarPrimitivos {\n    public static void main(String[] args) {\n        int[] nums = {5, 1, 9};\n        Arrays.sort(nums);\n        System.out.println(Arrays.toString(nums)); // [1, 5, 9]\n    }\n}```"}
{"instruction": "Muestra el uso de interfaces funcionales y expresiones Lambda.", "response": "Las expresiones Lambda simplifican la implementación de interfaces con un solo método abstracto.\n\n```java\ninterface Operacion { int calcular(int a, int b); }\n\npublic class LambdaEjemplo {\n    public static void main(String[] args) {\n        Operacion suma = (a, b) -> a + b;\n        System.out.println(suma.calcular(5, 3)); // 8\n    }\n}```"}
{"instruction": "Realiza una búsqueda binaria usando la clase utilitaria Arrays.", "response": "La búsqueda binaria requiere que el arreglo esté ordenado previamente.\n\n```java\nimport java.util.Arrays;\n\npublic class BusquedaSimple {\n    public static void main(String[] args) {\n        int[] arr = {10, 20, 30, 40};\n        int indice = Arrays.binarySearch(arr, 30);\n        System.out.println(\"Encontrado en índice: \" + indice);\n    }\n}```"}
{"instruction": "Explica el encapsulamiento en POO con getters y setters.", "response": "El encapsulamiento protege los datos haciéndolos privados y controlando el acceso mediante métodos públicos.\n\n```java\npublic class Usuario {\n    private String password;\n\n    public void setPassword(String pass) {\n        if (pass.length() > 5) this.password = pass;\n    }\n}```"}
{"instruction": "Usa una Queue para simular una cola de impresión.", "response": "Se añaden documentos al final y se procesan desde el frente.\n\n```java\nimport java.util.LinkedList;\nimport java.util.Queue;\n\npublic class Impresora {\n    public static void main(String[] args) {\n        Queue<String> cola = new LinkedList<>();\n        cola.add(\"Doc1.pdf\");\n        cola.add(\"Foto.jpg\");\n        while(!cola.isEmpty()) {\n            System.out.println(\"Imprimiendo: \" + cola.poll());\n        }\n    }\n}```"}
{"instruction": "Explica la complejidad O(log n) con un ejemplo de código.", "response": "O(log n) ocurre cuando el espacio de búsqueda se reduce a la mitad en cada paso, como en un bucle que multiplica/divide el índice.\n\n```java\npublic int logaritmo(int n) {\n    int pasos = 0;\n    while (n > 1) {\n        n = n / 2;\n        pasos++;\n    }\n    return pasos;\n}```"}
{"instruction": "Implementa el algoritmo de ordenamiento de burbuja (Bubble Sort).", "response": "Es un algoritmo simple O(n^2) que intercambia elementos adyacentes si están en el orden incorrecto.\n\n```java\npublic void bubbleSort(int[] arr) {\n    for (int i = 0; i < arr.length - 1; i++) {\n        for (int j = 0; j < arr.length - i - 1; j++) {\n            if (arr[j] > arr[j+1]) {\n                int temp = arr[j];\n                arr[j] = arr[j+1];\n                arr[j+1] = temp;\n            }\n        }\n    }\n}```"}
{"instruction": "Explica el uso básico de HashMap para asociar claves y valores.", "response": "`HashMap` permite guardar datos en pares clave-valor, con acceso muy rápido.\n\n```java\nimport java.util.HashMap;\n\npublic class Inventario {\n    public static void main(String[] args) {\n        HashMap<String, Integer> stock = new HashMap<>();\n        stock.put(\"Manzanas\", 50);\n        System.out.println(\"Stock: \" + stock.get(\"Manzanas\"));\n    }\n}```"}
{"instruction": "Muestra cómo usar TreeMap para mantener las claves ordenadas.", "response": "A diferencia de HashMap, `TreeMap` mantiene las claves ordenadas según su orden natural o un comparador.\n\n```java\nimport java.util.TreeMap;\n\npublic class AgendaOrdenada {\n    public static void main(String[] args) {\n        TreeMap<String, String> agenda = new TreeMap<>();\n        agenda.put(\"Carlos\", \"123\");\n        agenda.put(\"Ana\", \"456\");\n        System.out.println(agenda.firstKey()); // \"Ana\"\n    }\n}```"}
{"instruction": "Utiliza una pila para verificar paréntesis balanceados.", "response": "Las pilas son ideales para validar estructuras anidadas como `(( ))`.\n\n```java\nimport java.util.Stack;\n\npublic boolean balanceado(String s) {\n    Stack<Character> stack = new Stack<>();\n    for (char c : s.toCharArray()) {\n        if (c == '(') stack.push(c);\n        else if (c == ')' && !stack.isEmpty()) stack.pop();\n        else return false;\n    }\n    return stack.isEmpty();\n}```"}
{"instruction": "Muestra cómo iterar una LinkedList usando un Iterator.", "response": "El iterador es la forma segura de recorrer colecciones, permitiendo eliminar elementos durante el recorrido.\n\n```java\nimport java.util.LinkedList;\nimport java.util.Iterator;\n\npublic class Recorrido {\n    public static void main(String[] args) {\n        LinkedList<String> lista = new LinkedList<>();\n        lista.add(\"A\");\n        Iterator<String> it = lista.iterator();\n        while(it.hasNext()) System.out.println(it.next());\n    }\n}```"}
{"instruction": "Explica qué es la clase Vector y su diferencia con ArrayList.", "response": "`Vector` es una clase antigua similar a ArrayList pero sincronizada (thread-safe), lo que la hace un poco más lenta.\n\n```java\nimport java.util.Vector;\n\npublic class EjemploVector {\n    public static void main(String[] args) {\n        Vector<Integer> v = new Vector<>();\n        v.add(1);\n        v.add(2);\n        System.out.println(v.size());\n    }\n}```"}
{"instruction": "Explica cómo hacer un objeto elegible para el Garbage Collector.", "response": "Un objeto es elegible para recolección cuando no existen referencias activas apuntando a él.\n\n```java\npublic class Basura {\n    public static void main(String[] args) {\n        String s = new String(\"Dato\");\n        s = null; // La referencia se rompe, el objeto en Heap es basura\n        System.gc(); // Sugerencia a la JVM\n    }\n}```"}
{"instruction": "Demuestra que Java pasa las referencias por valor.", "response": "Al pasar un objeto a un método, se pasa una copia de la referencia, no el objeto en sí. Reasignar la variable local no afecta afuera.\n\n```java\npublic void intentarCambiar(String s) {\n    s = \"Nuevo Valor\"; // Solo cambia la referencia local 's'\n}\n// El string original fuera de este método permanece intacto.```"}
{"instruction": "Muestra el uso de BlockingQueue para hilos productores-consumidores.", "response": "`BlockingQueue` es thread-safe y bloquea el hilo si intenta sacar de una cola vacía o poner en una llena.\n\n```java\nimport java.util.concurrent.ArrayBlockingQueue;\nimport java.util.concurrent.BlockingQueue;\n\npublic class ColaBloqueante {\n    public static void main(String[] args) throws InterruptedException {\n        BlockingQueue<Integer> bq = new ArrayBlockingQueue<>(10);\n        bq.put(100); // Espera si es necesario\n        System.out.println(bq.take()); // Espera si está vacía\n    }\n}```"}
{"instruction": "Ordena una lista en orden inverso (descendente).", "response": "Puedes usar `Collections.sort` con `Collections.reverseOrder()`.\n\n```java\nimport java.util.*;\n\npublic class OrdenReverso {\n    public static void main(String[] args) {\n        List<Integer> lista = Arrays.asList(1, 5, 3);\n        Collections.sort(lista, Collections.reverseOrder());\n        System.out.println(lista); // [5, 3, 1]\n    }\n}```"}
{"instruction": "Explica el concepto de Herencia en Java con `extends`.", "response": "La herencia permite a una clase hija adquirir atributos y métodos de una clase padre.\n\n```java\nclass Animal { void comer() { System.out.println(\"Ñam\"); } }\n\nclass Perro extends Animal {\n    void ladrar() { System.out.println(\"Guau\"); }\n}\n// Perro tiene comer() y ladrar()```"}
{"instruction": "Genera un StackOverflowError intencionalmente con recursión.", "response": "Este error ocurre cuando la recursión no tiene caso base y se llena la memoria de pila.\n\n```java\npublic void recursividadInfinita() {\n    recursividadInfinita(); // Se llama eternamente\n}```"}
{"instruction": "Implementa la serie de Fibonacci de forma recursiva.", "response": "Fibonacci es la suma de los dos números anteriores. F(n) = F(n-1) + F(n-2).\n\n```java\npublic int fibonacci(int n) {\n    if (n <= 1) return n;\n    return fibonacci(n - 1) + fibonacci(n - 2);\n}```"}
{"instruction": "Explica los métodos por defecto (default methods) en interfaces.", "response": "Desde Java 8, las interfaces pueden tener métodos con implementación usando `default`.\n\n```java\ninterface Saludable {\n    default void saludar() {\n        System.out.println(\"Hola genérico\");\n    }\n}\nclass Persona implements Saludable { /* Hereda saludar() automáticamente */ }```"}
{"instruction": "Utiliza LinkedHashMap para mantener el orden de inserción.", "response": "`LinkedHashMap` recuerda el orden en que se insertaron las claves, a diferencia de HashMap normal.\n\n```java\nimport java.util.LinkedHashMap;\n\npublic class MapaOrdenado {\n    public static void main(String[] args) {\n        LinkedHashMap<String, Integer> lhm = new LinkedHashMap<>();\n        lhm.put(\"Primero\", 1);\n        lhm.put(\"Segundo\", 2);\n        System.out.println(lhm.keySet()); // [Primero, Segundo]\n    }\n}```"}
{"instruction": "Muestra la lógica conceptual del Merge Sort (Divide y Vencerás).", "response": "Merge Sort divide el array recursivamente en mitades y luego las mezcla ordenadamente.\n\n```java\npublic void mergeSort(int[] arr, int n) {\n    if (n < 2) return;\n    int mid = n / 2;\n    int[] l = new int[mid];\n    int[] r = new int[n - mid];\n    // Llenar l y r, luego llamar recursivamente y mezclar (merge)\n}```"}
{"instruction": "Itera sobre las claves de un mapa usando keySet().", "response": "El método `keySet()` devuelve un Set con todas las claves del mapa.\n\n```java\nimport java.util.Map;\nimport java.util.HashMap;\n\npublic class Llaves {\n    public static void main(String[] args) {\n        Map<String, Integer> mapa = new HashMap<>();\n        mapa.put(\"X\", 10);\n        for (String clave : mapa.keySet()) {\n            System.out.println(\"Clave: \" + clave);\n        }\n    }\n}```"}
{"instruction": "Invierte una cadena de texto usando una Pila (Stack).", "response": "Al meter caracteres en una pila y sacarlos, salen en orden inverso.\n\n```java\nimport java.util.Stack;\n\npublic String invertir(String str) {\n    Stack<Character> pila = new Stack<>();\n    for (char c : str.toCharArray()) pila.push(c);\n    StringBuilder sb = new StringBuilder();\n    while (!pila.isEmpty()) sb.append(pila.pop());\n    return sb.toString();\n}```"}
{"instruction": "Explica el uso de BitSet para manejo eficiente de bits.", "response": "`BitSet` maneja un vector de bits que crece dinámicamente, usando menos memoria que un `boolean[]`.\n\n```java\nimport java.util.BitSet;\n\npublic class Bits {\n    public static void main(String[] args) {\n        BitSet bits = new BitSet();\n        bits.set(5); // Pone el bit en índice 5 a true\n        System.out.println(bits.get(5)); // true\n    }\n}```"}
{"instruction": "Representa un grafo utilizando una Matriz de Adyacencia.", "response": "Una matriz NxN donde `matriz[i][j] = 1` indica una conexión entre el nodo i y j.\n\n```java\npublic class GrafoMatriz {\n    int[][] matriz;\n    public GrafoMatriz(int nodos) {\n        matriz = new int[nodos][nodos];\n    }\n    public void conectar(int i, int j) {\n        matriz[i][j] = 1;\n        matriz[j][i] = 1; // Si es no dirigido\n    }\n}```"}
{"instruction": "Explica el Polimorfismo en Java con un ejemplo simple.", "response": "El polimorfismo permite que una referencia de tipo padre apunte a un objeto hijo y ejecute el método del hijo.\n\n```java\nclass Animal { void hablar() { System.out.println(\"...\"); } }\nclass Gato extends Animal { void hablar() { System.out.println(\"Miau\"); } }\n\n// Uso:\nAnimal a = new Gato();\na.hablar(); // Imprime \"Miau\"```"}
{"instruction": "Compara la complejidad de acceso (get) entre ArrayList y LinkedList.", "response": "`ArrayList` tiene acceso O(1) (inmediato), `LinkedList` tiene acceso O(n) (debe recorrer).\n\n```java\nimport java.util.List;\n// ArrayList.get(1000) -> Instantáneo\n// LinkedList.get(1000) -> Tiene que saltar 1000 nodos\npublic void acceder(List<Integer> lista, int idx) {\n    System.out.println(lista.get(idx));\n}```"}
{"instruction": "Explica la complejidad espacial O(n) al copiar un arreglo.", "response": "Si creas un nuevo arreglo del mismo tamaño que la entrada, consumes memoria lineal O(n).\n\n```java\npublic int[] copiar(int[] origen) {\n    int[] destino = new int[origen.length]; // O(n) espacio extra\n    for(int i=0; i<origen.length; i++) destino[i] = origen[i];\n    return destino;\n}```"}
{"instruction": "Explica el concepto de bucle infinito y su impacto en la complejidad temporal.", "response": "Un bucle infinito tiene una complejidad teórica de O(∞). Ocurre cuando la condición de salida nunca se cumple.\n\n```java\npublic void bucleEterno() {\n    while (true) {\n        System.out.println(\"Esto nunca termina...\");\n        // Falta una condición de ruptura (break) o cambio de estado\n    }\n}```"}
{"instruction": "Implementa una Pila (Stack) simple utilizando un arreglo en lugar de la clase nativa.", "response": "Podemos simular el comportamiento LIFO controlando un índice que apunta al tope de la pila.\n\n```java\nclass PilaManual {\n    int[] datos = new int[100];\n    int tope = -1;\n\n    void push(int valor) {\n        datos[++tope] = valor;\n    }\n    int pop() {\n        return datos[tope--];\n    }\n}```"}
{"instruction": "Explica el concepto de String Pool en la memoria de Java.", "response": "Java optimiza memoria guardando literales de String en un pool especial en el Heap. Las cadenas idénticas comparten referencia.\n\n```java\npublic class StringPool {\n    public static void main(String[] args) {\n        String s1 = \"Hola\";\n        String s2 = \"Hola\";\n        // s1 == s2 es true (misma referencia en pool)\n        String s3 = new String(\"Hola\");\n        // s1 == s3 es false (s3 es un objeto nuevo fuera del pool)\n    }\n}```"}
{"instruction": "Demuestra la abstracción en POO simulando una cuenta bancaria.", "response": "La abstracción oculta la complejidad interna, exponiendo solo métodos seguros como retirar o depositar.\n\n```java\npublic class Cuenta {\n    private double saldo;\n    \n    public void retirar(double monto) {\n        if (monto <= saldo) {\n            saldo -= monto;\n        } else {\n            System.out.println(\"Fondos insuficientes\");\n        }\n    }\n}```"}
{"instruction": "Implementa una búsqueda binaria iterativa manualmente.", "response": "La versión iterativa es eficiente en espacio (O(1)) comparada con la recursiva.\n\n```java\npublic int busquedaBinaria(int[] arr, int objetivo) {\n    int izq = 0, der = arr.length - 1;\n    while (izq <= der) {\n        int medio = izq + (der - izq) / 2;\n        if (arr[medio] == objetivo) return medio;\n        if (arr[medio] < objetivo) izq = medio + 1;\n        else der = medio - 1;\n    }\n    return -1;\n}```"}
{"instruction": "Muestra cómo insertar un nodo en un Árbol Binario de Búsqueda (BST) de forma recursiva.", "response": "En un BST, los valores menores van a la izquierda y los mayores a la derecha.\n\n```java\npublic NodoArbol insertar(NodoArbol actual, int valor) {\n    if (actual == null) return new NodoArbol(valor);\n    if (valor < actual.valor) \n        actual.izquierdo = insertar(actual.izquierdo, valor);\n    else if (valor > actual.valor) \n        actual.derecho = insertar(actual.derecho, valor);\n    return actual;\n}```"}
{"instruction": "Usa Collections.binarySearch para buscar en una Lista.", "response": "`Collections.binarySearch` funciona en listas que implementan `List`, pero deben estar ordenadas previamente.\n\n```java\nimport java.util.*;\n\npublic class BusquedaLista {\n    public static void main(String[] args) {\n        List<Integer> nums = new ArrayList<>(Arrays.asList(1, 3, 5, 7));\n        int pos = Collections.binarySearch(nums, 5);\n        System.out.println(\"Posición: \" + pos); // 2\n    }\n}```"}
{"instruction": "Diferencia entre peek() y remove() en una cola (Queue).", "response": "`peek()` recupera el elemento frontal sin eliminarlo, mientras que `remove()` lo recupera y lo elimina.\n\n```java\nimport java.util.LinkedList;\nimport java.util.Queue;\n\npublic class VistazoCola {\n    public static void main(String[] args) {\n        Queue<String> q = new LinkedList<>();\n        q.add(\"Primero\");\n        System.out.println(q.peek()); // \"Primero\" (sigue en la cola)\n        System.out.println(q.remove()); // \"Primero\" (ya no está)\n    }\n}```"}
{"instruction": "Explica el bloque try-with-resources para manejo automático de recursos.", "response": "Introducido en Java 7, cierra automáticamente recursos que implementan `AutoCloseable` (como archivos o sockets).\n\n```java\nimport java.io.*;\n\npublic class LeerArchivo {\n    public static void leer(String ruta) {\n        try (BufferedReader br = new BufferedReader(new FileReader(ruta))) {\n            System.out.println(br.readLine());\n        } catch (IOException e) {\n            e.printStackTrace();\n        } // br se cierra aquí automáticamente\n    }\n}```"}
{"instruction": "Simula el botón 'Atrás' de un navegador usando una Pila.", "response": "Cada nueva página se empuja a la pila. Al volver atrás, se hace pop.\n\n```java\nimport java.util.Stack;\n\npublic class Navegador {\n    public static void main(String[] args) {\n        Stack<String> historial = new Stack<>();\n        historial.push(\"Google\");\n        historial.push(\"Wikipedia\");\n        System.out.println(\"Regresando a: \" + historial.pop()); // Google\n    }\n}```"}
{"instruction": "Implementa una búsqueda lineal (Linear Search) y explica su complejidad.", "response": "Recorre elemento por elemento. Su complejidad es O(n), útil para datos no ordenados.\n\n```java\npublic int busquedaLineal(int[] arr, int x) {\n    for (int i = 0; i < arr.length; i++) {\n        if (arr[i] == x) return i;\n    }\n    return -1;\n}```"}
{"instruction": "Ejemplo de algoritmo con complejidad O(1) usando operaciones aritméticas.", "response": "Determinar si un número es par o impar es una operación constante O(1).\n\n```java\npublic boolean esPar(int n) {\n    return n % 2 == 0;\n}```"}
{"instruction": "Usa una clase abstracta para definir una plantilla de Figuras Geométricas.", "response": "Las clases abstractas pueden tener constructores y estado, a diferencia de las interfaces (antes de Java 8/9).\n\n```java\nabstract class Figura {\n    abstract double area();\n}\n\nclass Circulo extends Figura {\n    double r;\n    Circulo(double r) { this.r = r; }\n    double area() { return Math.PI * r * r; }\n}```"}
{"instruction": "Implementa un método para agregar al inicio en una lista enlazada personalizada.", "response": "Insertar al inicio es O(1) si mantenemos referencia a la cabeza (head).\n\n```java\nclass ListaCustom {\n    NodoSimple head;\n    public void agregarInicio(int dato) {\n        NodoSimple nuevo = new NodoSimple(dato);\n        nuevo.siguiente = head;\n        head = nuevo;\n    }\n}```"}
{"instruction": "Explica el impacto de O(n^2) con un ejemplo de imprimir pares de números.", "response": "A medida que `n` crece, el tiempo de ejecución se cuadruplica si `n` se duplica.\n\n```java\npublic void imprimirCombinaciones(int n) {\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            System.out.println(i + \"-\" + j);\n        }\n    }\n}```"}
{"instruction": "Demuestra cómo una clase puede implementar múltiples interfaces.", "response": "Java permite herencia múltiple de tipos a través de interfaces.\n\n```java\ninterface Volador { void volar(); }\ninterface Nadador { void nadar(); }\n\nclass Pato implements Volador, Nadador {\n    public void volar() { System.out.println(\"Vuela\"); }\n    public void nadar() { System.out.println(\"Nada\"); }\n}```"}
{"instruction": "Muestra cómo eliminar el primer y último elemento de una LinkedList.", "response": "`LinkedList` tiene métodos específicos optimizados para operar en los extremos.\n\n```java\nimport java.util.LinkedList;\n\npublic class EliminarExtremos {\n    public static void main(String[] args) {\n        LinkedList<Integer> lista = new LinkedList<>();\n        lista.add(1); lista.add(2); lista.add(3);\n        lista.removeFirst(); // Queda [2, 3]\n        lista.removeLast();  // Queda [2]\n    }\n}```"}
{"instruction": "Implementa un recorrido Pre-Order en un árbol binario.", "response": "El orden es: Raíz -> Izquierda -> Derecha. Útil para copiar árboles.\n\n```java\npublic void preOrder(NodoArbol nodo) {\n    if (nodo == null) return;\n    System.out.print(nodo.valor + \" \");\n    preOrder(nodo.izquierdo);\n    preOrder(nodo.derecho);\n}```"}
{"instruction": "Elimina duplicados de un arreglo utilizando un HashSet.", "response": "Convertir un array a un Set es la forma más rápida de filtrar únicos.\n\n```java\nimport java.util.*;\n\npublic class FiltroDuplicados {\n    public static void main(String[] args) {\n        Integer[] nums = {1, 2, 2, 3};\n        Set<Integer> unicos = new HashSet<>(Arrays.asList(nums));\n        System.out.println(unicos); // [1, 2, 3]\n    }\n}```"}
{"instruction": "Cuenta la frecuencia de palabras en un texto usando HashMap.", "response": "Usamos la palabra como clave y el conteo como valor.\n\n```java\nimport java.util.*;\n\npublic class Frecuencia {\n    public static void main(String[] args) {\n        String[] palabras = {\"hola\", \"mundo\", \"hola\"};\n        Map<String, Integer> conteo = new HashMap<>();\n        for (String p : palabras) {\n            conteo.put(p, conteo.getOrDefault(p, 0) + 1);\n        }\n        System.out.println(conteo); // {mundo=1, hola=2}\n    }\n}```"}
{"instruction": "Explica la complejidad exponencial O(2^n) con Fibonacci recursivo.", "response": "Cada llamada genera dos llamadas más, creando un árbol de llamadas que crece exponencialmente.\n\n```java\npublic int fibonacciLento(int n) {\n    if (n <= 1) return n;\n    return fibonacciLento(n - 1) + fibonacciLento(n - 2);\n}```"}
{"instruction": "Muestra el uso de constructores en una clase abstracta.", "response": "Aunque no se pueden instanciar, las clases abstractas usan constructores para inicializar sus campos.\n\n```java\nabstract class Base {\n    Base() { System.out.println(\"Constructor Base inicializado\"); }\n}\n\nclass Hija extends Base {\n    Hija() { super(); }\n}```"}
{"instruction": "Calcula la altura de un árbol binario recursivamente.", "response": "La altura es el máximo entre la altura izquierda y derecha, más uno (por la raíz).\n\n```java\npublic int altura(NodoArbol nodo) {\n    if (nodo == null) return 0;\n    return 1 + Math.max(altura(nodo.izquierdo), altura(nodo.derecho));\n}```"}
{"instruction": "Invierte una lista enlazada de forma iterativa.", "response": "Se cambian los punteros 'siguiente' para que apunten al nodo anterior.\n\n```java\npublic NodoSimple invertirLista(NodoSimple head) {\n    NodoSimple prev = null;\n    NodoSimple current = head;\n    while (current != null) {\n        NodoSimple nextTemp = current.siguiente;\n        current.siguiente = prev;\n        prev = current;\n        current = nextTemp;\n    }\n    return prev;\n}```"}
{"instruction": "Utiliza ArrayDeque como una pila (Stack) LIFO estándar.", "response": "Es la implementación recomendada por la documentación de Java para pilas.\n\n```java\nimport java.util.ArrayDeque;\n\npublic class DequeStack {\n    public static void main(String[] args) {\n        ArrayDeque<Integer> stack = new ArrayDeque<>();\n        stack.push(100);\n        stack.push(200);\n        System.out.println(stack.pop()); // 200\n    }\n}```"}
{"instruction": "Usa TreeSet para almacenar números ordenados automáticamente.", "response": "`TreeSet` implementa `SortedSet`, manteniendo los elementos en orden ascendente (O(log n) inserción).\n\n```java\nimport java.util.TreeSet;\n\npublic class SetOrdenado {\n    public static void main(String[] args) {\n        TreeSet<Integer> set = new TreeSet<>();\n        set.add(5); set.add(1); set.add(10);\n        System.out.println(set); // [1, 5, 10]\n    }\n}```"}
{"instruction": "Crea un Max-Heap utilizando PriorityQueue y un comparador.", "response": "Por defecto `PriorityQueue` es Min-Heap. Usamos `Collections.reverseOrder()` para invertirlo.\n\n```java\nimport java.util.PriorityQueue;\nimport java.util.Collections;\n\npublic class MaxHeap {\n    public static void main(String[] args) {\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\n        pq.add(10); pq.add(50); pq.add(20);\n        System.out.println(pq.poll()); // 50 (el mayor)\n    }\n}```"}
{"instruction": "Define una clase simple con un constructor y un método.", "response": "Estructura básica de una clase en Java.\n\n```java\nclass Coche {\n    String modelo;\n    Coche(String modelo) { this.modelo = modelo; }\n    void arrancar() { System.out.println(modelo + \" arrancando.\"); }\n}```"}
{"instruction": "Verifica si una pila está vacía antes de sacar elementos.", "response": "Es crucial verificar `isEmpty()` para evitar `EmptyStackException`.\n\n```java\nimport java.util.Stack;\n\npublic void vaciarPila(Stack<String> pila) {\n    while (!pila.isEmpty()) {\n        System.out.println(pila.pop());\n    }\n}```"}
{"instruction": "Implementa el algoritmo de ordenamiento por Inserción (Insertion Sort).", "response": "Construye el arreglo ordenado uno a uno, insertando el elemento actual en su posición correcta a la izquierda.\n\n```java\npublic void insertionSort(int[] arr) {\n    for (int i = 1; i < arr.length; i++) {\n        int key = arr[i];\n        int j = i - 1;\n        while (j >= 0 && arr[j] > key) {\n            arr[j + 1] = arr[j];\n            j--;\n        }\n        arr[j + 1] = key;\n    }\n}```"}
{"instruction": "Implementa el algoritmo de ordenamiento por Selección (Selection Sort).", "response": "Busca el mínimo elemento y lo coloca al principio, repitiendo para el resto.\n\n```java\npublic void selectionSort(int[] arr) {\n    for (int i = 0; i < arr.length - 1; i++) {\n        int minIdx = i;\n        for (int j = i + 1; j < arr.length; j++)\n            if (arr[j] < arr[minIdx]) minIdx = j;\n        \n        int temp = arr[minIdx];\n        arr[minIdx] = arr[i];\n        arr[i] = temp;\n    }\n}```"}
{"instruction": "Suma los elementos de un arreglo usando recursión.", "response": "Dividimos el problema: la suma es el elemento actual más la suma del resto del arreglo.\n\n```java\npublic int sumar(int[] arr, int n) {\n    if (n <= 0) return 0;\n    return arr[n - 1] + sumar(arr, n - 1);\n}```"}
{"instruction": "Diferencia entre offer() y add() en una Cola.", "response": "`add()` lanza excepción si no hay espacio, `offer()` retorna false (más seguro en colas con capacidad limitada).\n\n```java\nimport java.util.concurrent.ArrayBlockingQueue;\n\npublic class OfferVsAdd {\n    public static void main(String[] args) {\n        ArrayBlockingQueue<Integer> q = new ArrayBlockingQueue<>(1);\n        q.add(1);\n        // q.add(2); // Lanzaría excepción\n        System.out.println(q.offer(2)); // Imprime false\n    }\n}```"}
{"instruction": "Ordena una lista de objetos usando un Comparator personalizado.", "response": "Los comparadores permiten definir reglas de ordenamiento ad-hoc (ej. por longitud de cadena).\n\n```java\nimport java.util.*;\n\npublic class OrdenPorLongitud {\n    public static void main(String[] args) {\n        List<String> lista = Arrays.asList(\"Ana\", \"Roberto\", \"Yo\");\n        lista.sort((a, b) -> a.length() - b.length());\n        System.out.println(lista); // [Yo, Ana, Roberto]\n    }\n}```"}
{"instruction": "Escribe la función 'merge' auxiliar para el Merge Sort.", "response": "Esta función combina dos sub-arreglos ordenados en uno solo.\n\n```java\nvoid merge(int[] arr, int l, int m, int r) {\n    int n1 = m - l + 1, n2 = r - m;\n    int[] L = new int[n1], R = new int[n2];\n    // (Código de copiado y mezcla de L y R en arr omitido por brevedad)\n}```"}
{"instruction": "Explica qué sucede con las referencias al asignar un arreglo a otro.", "response": "Ambas variables apuntan al mismo objeto en memoria. Modificar una afecta a la otra.\n\n```java\npublic class Alias {\n    public static void main(String[] args) {\n        int[] a = {10};\n        int[] b = a;\n        b[0] = 50;\n        System.out.println(a[0]); // 50\n    }\n}```"}
{"instruction": "Calcula la potencia de un número (x^n) recursivamente.", "response": "Definición matemática: x^n = x * x^(n-1), con caso base n=0 devuelve 1.\n\n```java\npublic int potencia(int x, int n) {\n    if (n == 0) return 1;\n    return x * potencia(x, n - 1);\n}```"}
{"instruction": "Muestra el uso de métodos estáticos dentro de una interfaz (Java 8+).", "response": "Las interfaces pueden contener métodos utilitarios estáticos que no dependen de la instancia.\n\n```java\ninterface Util {\n    static void imprimirInfo() {\n        System.out.println(\"Método estático de interfaz\");\n    }\n}\n// Uso: Util.imprimirInfo();```"}
{"instruction": "Ejemplo de bucle con complejidad O(log n) que no sea búsqueda binaria.", "response": "Un bucle donde el iterador se multiplica o divide en cada paso tiene complejidad logarítmica.\n\n```java\npublic void imprimirPotenciasDeDos(int n) {\n    for (int i = 1; i < n; i *= 2) {\n        System.out.println(i);\n    }\n}```"}
{"instruction": "Implementa una versión simplificada de Búsqueda Binaria.", "response": "Versión estándar para encontrar un índice en un arreglo ordenado.\n\n```java\nint binarySearch(int[] arr, int target) {\n    int l = 0, r = arr.length - 1;\n    while (l <= r) {\n        int m = l + (r - l) / 2;\n        if (arr[m] == target) return m;\n        if (arr[m] < target) l = m + 1;\n        else r = m - 1;\n    }\n    return -1;\n}```"}
{"instruction": "Implementa un recorrido DFS (Profundidad) en un grafo.", "response": "DFS explora tan profundo como sea posible antes de retroceder, usando recursión o pila.\n\n```java\npublic void dfs(int v, boolean[] visitados, List<List<Integer>> grafo) {\n    visitados[v] = true;\n    System.out.print(v + \" \");\n    for (int vecino : grafo.get(v)) {\n        if (!visitados[vecino]) dfs(vecino, visitados, grafo);\n    }\n}```"}
{"instruction": "Usa putIfAbsent en un Map para evitar sobrescribir valores.", "response": "Agrega la clave solo si no existe o está asignada a null.\n\n```java\nimport java.util.HashMap;\n\npublic class MapaSeguro {\n    public static void main(String[] args) {\n        HashMap<String, Integer> map = new HashMap<>();\n        map.put(\"A\", 1);\n        map.putIfAbsent(\"A\", 2); // No hace nada\n        System.out.println(map.get(\"A\")); // 1\n    }\n}```"}
{"instruction": "Implementa la búsqueda binaria de forma recursiva.", "response": "Pasa los límites izquierdo y derecho como argumentos en cada llamada.\n\n```java\npublic int busquedaBinariaRec(int[] arr, int l, int r, int x) {\n    if (r >= l) {\n        int mid = l + (r - l) / 2;\n        if (arr[mid] == x) return mid;\n        if (arr[mid] > x) return busquedaBinariaRec(arr, l, mid - 1, x);\n        return busquedaBinariaRec(arr, mid + 1, r, x);\n    }\n    return -1;\n}```"}
{"instruction": "Usa el método search() de la clase Stack.", "response": "Devuelve la posición basada en 1 desde la cima de la pila.\n\n```java\nimport java.util.Stack;\n\npublic class BuscarPila {\n    public static void main(String[] args) {\n        Stack<String> s = new Stack<>();\n        s.push(\"Base\");\n        s.push(\"Cima\");\n        System.out.println(s.search(\"Base\")); // 2 (está debajo de Cima)\n    }\n}```"}
{"instruction": "Explica la complejidad factorial O(n!) con un ejemplo de permutaciones.", "response": "Generar todas las permutaciones de una cadena es una operación extremadamente costosa.\n\n```java\npublic void permutaciones(String str, String res) {\n    if (str.length() == 0) System.out.println(res);\n    for (int i = 0; i < str.length(); i++) {\n        char ch = str.charAt(i);\n        String resto = str.substring(0, i) + str.substring(i + 1);\n        permutaciones(resto, res + ch);\n    }\n}```"}
{"instruction": "Muestra la operación lógica AND entre dos BitSets.", "response": "Modifica el primer BitSet para contener solo los bits presentes en ambos.\n\n```java\nimport java.util.BitSet;\n\npublic class BitSetAnd {\n    public static void main(String[] args) {\n        BitSet b1 = new BitSet(); b1.set(1); b1.set(2);\n        BitSet b2 = new BitSet(); b2.set(1);\n        b1.and(b2); // Intersección\n        System.out.println(b1); // {1}\n    }\n}```"}
{"instruction": "Realiza una búsqueda binaria en un arreglo de objetos comparables.", "response": "Los objetos deben implementar `Comparable` para definir su orden natural.\n\n```java\nclass Item implements Comparable<Item> {\n    int id;\n    public int compareTo(Item o) { return this.id - o.id; }\n}\n// Arrays.binarySearch(items, targetItem);```"}
{"instruction": "Detecta si una lista enlazada tiene un ciclo (Algoritmo de Floyd).", "response": "Usa dos punteros, uno lento y uno rápido. Si se encuentran, hay un ciclo.\n\n```java\npublic boolean tieneCiclo(NodoSimple head) {\n    NodoSimple lento = head, rapido = head;\n    while (rapido != null && rapido.siguiente != null) {\n        lento = lento.siguiente;\n        rapido = rapido.siguiente.siguiente;\n        if (lento == rapido) return true;\n    }\n    return false;\n}```"}
{"instruction": "Explica qué es una interfaz funcional.", "response": "Es una interfaz con exactamente un método abstracto, base para las Lambdas.\n\n```java\n@FunctionalInterface\ninterface Calculadora {\n    int operar(int a, int b);\n}\n// Calculadora suma = (a, b) -> a + b;```"}
{"instruction": "Muestra cómo verificar rangos antes de una búsqueda binaria para optimizar.", "response": "Si el objetivo es menor que el primer elemento o mayor que el último, no es necesario buscar.\n\n```java\npublic boolean buscarSmart(int[] arrOrdenado, int target) {\n    if (arrOrdenado.length == 0) return false;\n    if (target < arrOrdenado[0] || target > arrOrdenado[arrOrdenado.length - 1]) \n        return false;\n    return Arrays.binarySearch(arrOrdenado, target) >= 0;\n}```"}
{"instruction": "Explica el concepto de interfaces y clases abstractas con un ejemplo en Java.", "response": "En Java, interfaces y clases abstractas se implementa utilizando estructuras nativas o clases personalizadas. Aquí tienes un ejemplo simple en Java relacionado con interfaces y clases abstractas.\n\n```java\ninterface Animal {\n    void hacerSonido();\n}\n\nabstract class Mamifero implements Animal {\n    // Método concreto en clase abstracta\n    void dormir() {\n        System.out.println(\"Zzz\");\n    }\n}\n\nclass Perro extends Mamifero {\n    @Override\n    public void hacerSonido() {\n        System.out.println(\"Guau\");\n    }\n}```"}
{"instruction": "Crea una lista enlazada sincronizada (Thread-safe) en Java.", "response": "Para entornos multi-hilo, `LinkedList` no es segura por defecto. Se puede envolver con `Collections`.\n\n```java\nimport java.util.*;\n\npublic class ListaSegura {\n    public static void main(String[] args) {\n        List<String> lista = Collections.synchronizedList(new LinkedList<>());\n        lista.add(\"Seguro\");\n        synchronized(lista) {\n            for(String s : lista) System.out.println(s);\n        }\n    }\n}```"}
{"instruction": "Implementa un método para verificar si un nodo de un árbol binario es una hoja.", "response": "Un nodo es hoja si no tiene hijos (ambas referencias son null).\n\n```java\npublic boolean esHoja(NodoArbol nodo) {\n    if (nodo == null) return false;\n    return nodo.izquierdo == null && nodo.derecho == null;\n}```"}
{"instruction": "Muestra cómo usar una clase anónima para implementar una interfaz.", "response": "Útil para implementaciones de un solo uso sin crear un archivo de clase separado.\n\n```java\ninterface Evento { void click(); }\n\npublic class Boton {\n    public void registrar() {\n        Evento e = new Evento() {\n            @Override public void click() { System.out.println(\"Click detectado\"); }\n        };\n        e.click();\n    }\n}```"}
{"instruction": "Combina una clase abstracta con un método concreto heredado.", "response": "Las subclases heredan el comportamiento concreto de la clase abstracta sin necesidad de reescribirlo.\n\n```java\nabstract class Mamifero {\n    void dormir() { System.out.println(\"Zzz...\"); }\n}\n\nclass Gato extends Mamifero {\n    // Hereda dormir() automáticamente\n}```"}
{"instruction": "Modela una clase simple 'Libro' con atributos privados y constructor.", "response": "Ejemplo básico de modelado de objetos del mundo real.\n\n```java\npublic class Libro {\n    private String titulo;\n    private String autor;\n\n    public Libro(String titulo, String autor) {\n        this.titulo = titulo;\n        this.autor = autor;\n    }\n    public String getDetalles() { return titulo + \" por \" + autor; }\n}```"}
{"instruction": "Invierte el contenido de un arreglo utilizando una Pila auxiliar.", "response": "Aprovecha la naturaleza LIFO de la pila para invertir secuencias.\n\n```java\nimport java.util.Stack;\n\npublic void invertirArray(int[] arr) {\n    Stack<Integer> stack = new Stack<>();\n    for (int n : arr) stack.push(n);\n    for (int i = 0; i < arr.length; i++) arr[i] = stack.pop();\n}```"}
{"instruction": "Define un nodo de árbol que almacene un valor genérico.", "response": "Uso de Generics para crear estructuras de datos flexibles.\n\n```java\nclass NodoGenerico<T> {\n    T valor;\n    NodoGenerico<T> izq, der;\n    public NodoGenerico(T valor) { this.valor = valor; }\n}```"}
{"instruction": "Busca un valor específico dentro de un Árbol Binario de Búsqueda (BST).", "response": "Aprovecha el orden del BST para buscar en O(log n) promedio.\n\n```java\npublic boolean buscarBST(NodoArbol nodo, int valor) {\n    if (nodo == null) return false;\n    if (nodo.valor == valor) return true;\n    return valor < nodo.valor \n        ? buscarBST(nodo.izquierdo, valor) \n        : buscarBST(nodo.derecho, valor);\n}```"}
{"instruction": "Usa getOrDefault en un Map para manejar valores nulos de forma segura.", "response": "Evita comprobaciones manuales de nulidad al recuperar valores.\n\n```java\nimport java.util.HashMap;\n\npublic class Capitales {\n    public static void main(String[] args) {\n        HashMap<String, String> capitales = new HashMap<>();\n        capitales.put(\"España\", \"Madrid\");\n        System.out.println(capitales.getOrDefault(\"Francia\", \"No encontrada\"));\n    }\n}```"}
{"instruction": "Implementa una cuenta regresiva simple usando recursión.", "response": "Imprime números desde n hasta 0.\n\n```java\npublic void cuentaRegresiva(int n) {\n    if (n < 0) return;\n    System.out.println(n);\n    cuentaRegresiva(n - 1);\n}```"}
{"instruction": "Cuenta el número total de nodos en un árbol binario recursivamente.", "response": "La suma es 1 (raíz) + nodos izquierda + nodos derecha.\n\n```java\npublic int contarNodos(NodoArbol nodo) {\n    if (nodo == null) return 0;\n    return 1 + contarNodos(nodo.izquierdo) + contarNodos(nodo.derecho);\n}```"}
{"instruction": "Suma los dígitos de un número entero usando recursión.", "response": "Ejemplo: sumaDigitos(123) -> 1+2+3 = 6.\n\n```java\npublic int sumaDigitos(int n) {\n    if (n == 0) return 0;\n    return (n % 10) + sumaDigitos(n / 10);\n}```"}
{"instruction": "Encuentra el valor máximo en un arreglo (Complejidad O(n)).", "response": "Requiere recorrer todo el arreglo al menos una vez.\n\n```java\npublic int maximo(int[] arr) {\n    int max = arr[0];\n    for (int i = 1; i < arr.length; i++) {\n        if (arr[i] > max) max = arr[i];\n    }\n    return max;\n}```"}
{"instruction": "Explica la complejidad O(n*m) con bucles anidados dependientes de distintas variables.", "response": "Ocurre al procesar estructuras rectangulares o cruzar dos listas de distinto tamaño.\n\n```java\npublic void procesar(int n, int m) {\n    for(int i=0; i<n; i++) \n        for(int j=0; j<m; j++) \n            System.out.println(i + \",\" + j);\n}```"}
{"instruction": "Realiza una búsqueda binaria en un arreglo de caracteres.", "response": "`Arrays.binarySearch` tiene sobrecargas para todos los tipos primitivos.\n\n```java\nimport java.util.Arrays;\n\npublic class BusquedaChar {\n    public static void main(String[] args) {\n        char[] letras = {'a', 'c', 'e', 'z'};\n        System.out.println(Arrays.binarySearch(letras, 'c')); // 1\n    }\n}```"}
{"instruction": "Explica por qué obtener el tamaño de una lista es O(1).", "response": "Las colecciones en Java mantienen una variable interna `size` que se actualiza al insertar/borrar.\n\n```java\nimport java.util.List;\npublic int obtenerTamano(List<String> lista) {\n    return lista.size(); // Retorno inmediato del atributo interno\n}```"}
{"instruction": "Simula un algoritmo Round Robin básico usando una Cola.", "response": "Los procesos se ejecutan y si no terminan, vuelven al final de la cola.\n\n```java\nimport java.util.*;\n\npublic void roundRobin(Queue<String> procesos) {\n    if (!procesos.isEmpty()) {\n        String actual = procesos.poll();\n        System.out.println(\"Ejecutando \" + actual);\n        // Si no terminó, volver a añadir: procesos.add(actual);\n    }\n}```"}
{"instruction": "Verifica si existe un camino entre dos nodos (BFS simplificado).", "response": "Retorna true si se encuentra el nodo destino partiendo del origen.\n\n```java\npublic boolean hayCamino(int inicio, int fin, Map<Integer, List<Integer>> adj) {\n    Queue<Integer> q = new LinkedList<>();\n    Set<Integer> visitados = new HashSet<>();\n    q.add(inicio); visitados.add(inicio);\n    \n    while(!q.isEmpty()) {\n        int nodo = q.poll();\n        if (nodo == fin) return true;\n        for (int v : adj.getOrDefault(nodo, new ArrayList<>())) {\n            if (visitados.add(v)) q.add(v);\n        }\n    }\n    return false;\n}```"}
{"instruction": "Implementa el concepto de MinStack (Pila que devuelve el mínimo en O(1)).", "response": "Se usa una segunda pila auxiliar para rastrear el mínimo en cada nivel.\n\n```java\nimport java.util.Stack;\nclass MinStack {\n    Stack<Integer> s = new Stack<>(), minS = new Stack<>();\n    void push(int x) {\n        s.push(x);\n        if (minS.isEmpty() || x <= minS.peek()) minS.push(x);\n    }\n    int getMin() { return minS.peek(); }\n}```"}
{"instruction": "Captura múltiples excepciones en un solo bloque catch.", "response": "Característica desde Java 7 para reducir la duplicación de código en manejo de errores.\n\n```java\npublic void riesgo() {\n    try {\n        int[] arr = new int[0];\n        arr[0] = 5 / 0;\n    } catch (ArrayIndexOutOfBoundsException | ArithmeticException e) {\n        System.out.println(\"Error matemático o de índice: \" + e);\n    }\n}```"}
{"instruction": "Imprime los elementos de un array en orden inverso recursivamente.", "response": "Imprime el elemento actual después de llamar a la función para el resto.\n\n```java\npublic void imprimirReverso(int[] arr, int i) {\n    if (i < 0) return;\n    System.out.println(arr[i]);\n    imprimirReverso(arr, i - 1);\n}```"}
{"instruction": "Convierte una List a un Array nativo.", "response": "El método `toArray` requiere pasar un array del tipo correcto para el tipado.\n\n```java\nimport java.util.*;\npublic class ListToArray {\n    public static void main(String[] args) {\n        List<String> lista = Arrays.asList(\"A\", \"B\");\n        String[] array = lista.toArray(new String[0]);\n        System.out.println(array[0]);\n    }\n}```"}
{"instruction": "Explica la complejidad O(n) del método contains() en LinkedList.", "response": "Para encontrar un elemento, la lista enlazada debe recorrer nodo por nodo.\n\n```java\nimport java.util.LinkedList;\npublic boolean existe(LinkedList<String> lista, String dato) {\n    // Recorre toda la lista internamente\n    return lista.contains(dato);\n}```"}
{"instruction": "Elimina una entrada de un Map solo si el valor coincide.", "response": "`remove(key, value)` es una operación atómica y segura.\n\n```java\nimport java.util.HashMap;\npublic void eliminarSeguro(HashMap<Integer, String> map) {\n    map.put(1, \"Java\");\n    boolean borrado = map.remove(1, \"Python\"); // Falso, no borra\n    map.remove(1, \"Java\"); // Borra\n}```"}
{"instruction": "Explica el área de memoria de variables estáticas (Static).", "response": "Las variables `static` pertenecen a la clase y se almacenan en el Metaspace (antes PermGen).\n\n```java\nclass Contador {\n    static int total = 0; // Compartido por todas las instancias\n    Contador() { total++; }\n}```"}
{"instruction": "Define la estructura de un nodo para una lista doblemente enlazada.", "response": "Incluye referencias al nodo anterior y al siguiente.\n\n```java\nclass NodoDoble {\n    int dato;\n    NodoDoble prev, next;\n    public NodoDoble(int dato) { this.dato = dato; }\n}```"}
{"instruction": "Verifica si una cadena es palíndromo usando recursión.", "response": "Compara el primer y último carácter y recure sobre la subcadena interna.\n\n```java\npublic boolean esPalindromo(String s) {\n    if (s.length() <= 1) return true;\n    if (s.charAt(0) != s.charAt(s.length()-1)) return false;\n    return esPalindromo(s.substring(1, s.length()-1));\n}```"}
{"instruction": "Usa Arrays.parallelSort para ordenar arreglos grandes.", "response": "Utiliza múltiples hilos para dividir la tarea de ordenamiento (Fork/Join).\n\n```java\nimport java.util.Arrays;\npublic class OrdenParalelo {\n    public static void main(String[] args) {\n        int[] grande = {5, 2, 8, 1, 9};\n        Arrays.parallelSort(grande);\n    }\n}```"}
{"instruction": "Encuentra el valor mínimo en un Árbol Binario de Búsqueda (BST).", "response": "En un BST, el mínimo siempre está en el nodo más a la izquierda.\n\n```java\npublic int minimoBST(NodoArbol raiz) {\n    NodoArbol actual = raiz;\n    while (actual.izquierdo != null) {\n        actual = actual.izquierdo;\n    }\n    return actual.valor;\n}```"}
{"instruction": "Explica la complejidad O(n log n) típica de ordenamientos eficientes.", "response": "Algoritmos como MergeSort o Timsort (usado por Java) tienen esta complejidad promedio.\n\n```java\nimport java.util.Collections;\nimport java.util.List;\n\npublic void ordenar(List<Integer> lista) {\n    // Java usa Timsort: O(n log n)\n    Collections.sort(lista);\n}```"}
{"instruction": "Ilustra un Memory Leak (fuga de memoria) usando una lista estática.", "response": "Si se añaden objetos a una lista estática y nunca se eliminan, la memoria nunca se libera.\n\n```java\nimport java.util.*;\npublic class Leak {\n    static List<Object> cacheEterna = new ArrayList<>();\n    public void agregarDatos() {\n        cacheEterna.add(new byte[1024]); // Nunca se limpia\n    }\n}```"}
{"instruction": "Usa búsqueda binaria para encontrar el punto de inserción.", "response": "Si el elemento no está, `binarySearch` devuelve `-(punto_insercion) - 1`.\n\n```java\nimport java.util.Arrays;\npublic int dondeInsertar(int[] arr, int key) {\n    int idx = Arrays.binarySearch(arr, key);\n    return (idx < 0) ? -idx - 1 : idx;\n}```"}
{"instruction": "Explica la complejidad O(n + m) al ejecutar dos bucles secuenciales.", "response": "El tiempo total es la suma de los tiempos de cada bucle independiente.\n\n```java\npublic void dosFases(int[] a, int[] b) {\n    for(int x : a) System.out.print(x); // O(n)\n    for(int y : b) System.out.print(y); // O(m)\n}```"}
{"instruction": "Explica el costo de memoria del Autoboxing.", "response": "Convertir primitivos a objetos (`int` a `Integer`) consume más memoria y CPU.\n\n```java\npublic void overhead() {\n    Integer a = 10; // Crea objeto en Heap (costoso)\n    int b = 10;     // Valor en Stack (eficiente)\n}```"}
{"instruction": "Clona una LinkedList y explica la copia superficial (shallow copy).", "response": "El método `clone()` duplica la lista, pero los objetos dentro son las mismas referencias.\n\n```java\nimport java.util.LinkedList;\npublic class Clonar {\n    public static void main(String[] args) {\n        LinkedList<String> original = new LinkedList<>();\n        original.add(\"Dato\");\n        LinkedList<String> copia = (LinkedList<String>) original.clone();\n    }\n}```"}
{"instruction": "Explica el efecto de la palabra clave 'final' en una variable de referencia.", "response": "La referencia no puede cambiar, pero el estado interno del objeto sí.\n\n```java\npublic void testFinal() {\n    final StringBuilder sb = new StringBuilder(\"Hola\");\n    sb.append(\" Mundo\"); // Permitido\n    // sb = new StringBuilder(); // Error de compilación\n}```"}
{"instruction": "Crea una clase Arista (Edge) para grafos ponderados.", "response": "Necesaria para algoritmos como Dijkstra o Kruskal.\n\n```java\nclass Arista {\n    int origen, destino, peso;\n    public Arista(int o, int d, int p) {\n        this.origen = o; this.destino = d; this.peso = p;\n    }\n}```"}
{"instruction": "Explica la complejidad O(sqrt n) en un test de primalidad.", "response": "Solo necesitamos comprobar divisores hasta la raíz cuadrada del número.\n\n```java\npublic boolean esPrimo(int n) {\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}```"}
{"instruction": "Calcula el grado de un vértice en un grafo representado por listas.", "response": "El grado es simplemente el tamaño de la lista de adyacencia de ese nodo.\n\n```java\nimport java.util.*;\npublic int obtenerGrado(Map<Integer, List<Integer>> grafo, int nodo) {\n    return grafo.containsKey(nodo) ? grafo.get(nodo).size() : 0;\n}```"}
{"instruction": "Cuenta los componentes conexos en un grafo usando DFS.", "response": "Itera sobre todos los nodos e inicia un DFS si no ha sido visitado.\n\n```java\npublic int contarComponentes(int n, boolean[] visitado, List<List<Integer>> grafo) {\n    int count = 0;\n    for(int i=0; i<n; i++) {\n        if(!visitado[i]) {\n            // dfs(i, visitado, grafo); // Inicia recorrido\n            count++;\n        }\n    }\n    return count;\n}```"}
{"instruction": "Adapta la búsqueda binaria para un arreglo ordenado descendentemente.", "response": "La lógica de comparación se invierte: si `mid < target`, buscamos a la izquierda.\n\n```java\npublic int busquedaDesc(int[] arr, int target) {\n    int l = 0, r = arr.length - 1;\n    while(l <= r) {\n        int mid = l + (r - l)/2;\n        if(arr[mid] == target) return mid;\n        if(arr[mid] < target) r = mid - 1; // Invertido\n        else l = mid + 1;\n    }\n    return -1;\n}```"}
{"instruction": "Muestra el uso de WeakReference para permitir recolección de basura.", "response": "Permite referenciar un objeto sin impedir que el GC lo elimine si falta memoria.\n\n```java\nimport java.lang.ref.WeakReference;\npublic class RefDebil {\n    public static void main(String[] args) {\n        Object obj = new Object();\n        WeakReference<Object> weak = new WeakReference<>(obj);\n        obj = null; // Ahora es elegible para GC aunque 'weak' exista\n    }\n}```"}
{"instruction": "Convierte una LinkedList a ArrayList para mejorar el acceso aleatorio.", "response": "Estrategia común: construir con LinkedList, convertir a ArrayList para consultar.\n\n```java\nimport java.util.*;\npublic class Conversion {\n    public static void main(String[] args) {\n        LinkedList<String> ll = new LinkedList<>();\n        ll.add(\"A\");\n        ArrayList<String> al = new ArrayList<>(ll);\n        System.out.println(al.get(0));\n    }\n}```"}
{"instruction": "Explica conceptualmente el método finalize() (Deprecado).", "response": "Método que la JVM llamaba antes de recolectar el objeto. Hoy se prefieren `Cleaners` o `try-with-resources`.\n\n```java\n@Override\nprotected void finalize() throws Throwable {\n    // Código de limpieza antiguo\n    super.finalize();\n}```"}
{"instruction": "Representa un grafo como una lista de objetos Arista (Edge List).", "response": "Útil cuando lo importante son las relaciones y sus pesos, no la adyacencia rápida.\n\n```java\nimport java.util.ArrayList;\nclass GrafoListaAristas {\n    ArrayList<Arista> aristas = new ArrayList<>();\n    void agregar(int u, int v, int p) {\n        aristas.add(new Arista(u, v, p));\n    }\n}```"}
{"instruction": "Verifica si un árbol binario está vacío.", "response": "Simplemente comprueba si la raíz es nula.\n\n```java\npublic boolean estaVacio(NodoArbol raiz) {\n    return raiz == null;\n}```"}
{"instruction": "Obtén el tamaño de una Cola (Queue) en Java.", "response": "El método `size()` es parte de la interfaz Collection.\n\n```java\nimport java.util.Queue;\npublic void imprimirTamano(Queue<Integer> cola) {\n    System.out.println(\"Elementos pendientes: \" + cola.size());\n}```"}
{"instruction": "Resuelve el conflicto de métodos default al implementar dos interfaces.", "response": "Si dos interfaces tienen el mismo método default, la clase debe sobrescribirlo y elegir cuál llamar.\n\n```java\ninterface A { default void hola() { System.out.println(\"A\"); } }\ninterface B { default void hola() { System.out.println(\"B\"); } }\n\nclass C implements A, B {\n    public void hola() {\n        A.super.hola(); // Elige explícitamente A\n    }\n}```"}
{"instruction": "Verifica si un arreglo ya está ordenado (Complejidad O(n)).", "response": "Itera comprobando que cada elemento sea menor o igual al siguiente.\n\n```java\npublic boolean estaOrdenado(int[] arr) {\n    for(int i=0; i < arr.length-1; i++) {\n        if(arr[i] > arr[i+1]) return false;\n    }\n    return true;\n}```"}
{"instruction": "Explica la complejidad O(n^3) con la multiplicación de matrices.", "response": "Algoritmo clásico de tres bucles anidados para multiplicar matrices cuadradas.\n\n```java\npublic void multiplicar(int[][] A, int[][] B, int n) {\n    int[][] C = new int[n][n];\n    for(int i=0; i<n; i++)\n        for(int j=0; j<n; j++)\n            for(int k=0; k<n; k++)\n                C[i][j] += A[i][k] * B[k][j];\n}```"}
{"instruction": "Itera solo sobre los valores de un Map usando values().", "response": "Si no necesitas las claves, `values()` devuelve una colección con todos los valores almacenados.\n\n```java\nimport java.util.*;\n\npublic class SoloValores {\n    public static void main(String[] args) {\n        Map<String, Double> precios = new HashMap<>();\n        precios.put(\"Pan\", 1.50);\n        precios.put(\"Leche\", 0.90);\n        \n        for (Double precio : precios.values()) {\n            System.out.println(precio);\n        }\n    }\n}```"}
{"instruction": "Itera sobre pares clave-valor usando entrySet() (Forma más eficiente).", "response": "`entrySet()` permite acceder a la clave y al valor en la misma iteración sin tener que buscar de nuevo.\n\n```java\nimport java.util.Map;\n\npublic class IteracionEficiente {\n    public static void imprimirMapa(Map<String, Integer> mapa) {\n        for (Map.Entry<String, Integer> entrada : mapa.entrySet()) {\n            System.out.println(entrada.getKey() + \" -> \" + entrada.getValue());\n        }\n    }\n}```"}
{"instruction": "Calcula el Máximo Común Divisor (GCD) usando el algoritmo de Euclides recursivo.", "response": "El GCD de dos números también divide a su diferencia (o residuo).\n\n```java\npublic int gcd(int a, int b) {\n    if (b == 0) return a;\n    return gcd(b, a % b);\n}```"}
{"instruction": "Implementa un recorrido Post-Order en un árbol binario.", "response": "Orden: Izquierda -> Derecha -> Raíz. Útil para eliminar el árbol (liberar hijos antes que padre).\n\n```java\npublic void postOrder(NodoArbol nodo) {\n    if (nodo == null) return;\n    postOrder(nodo.izquierdo);\n    postOrder(nodo.derecho);\n    System.out.print(nodo.valor + \" \");\n}```"}
{"instruction": "Realiza un recorrido por niveles (Level Order) en un árbol usando una Cola.", "response": "Este es un algoritmo BFS aplicado a árboles para visitar nodo por nodo horizontalmente.\n\n```java\nimport java.util.*;\n\npublic void nivelPorNivel(NodoArbol raiz) {\n    if (raiz == null) return;\n    Queue<NodoArbol> q = new LinkedList<>();\n    q.add(raiz);\n    while(!q.isEmpty()) {\n        NodoArbol actual = q.poll();\n        System.out.print(actual.valor + \" \");\n        if (actual.izquierdo != null) q.add(actual.izquierdo);\n        if (actual.derecho != null) q.add(actual.derecho);\n    }\n}```"}
{"instruction": "Implementa una Cola (Queue) utilizando dos Pilas (Stacks).", "response": "Clásica pregunta de entrevista. `s1` para encolar, `s2` para desencolar invirtiendo el orden.\n\n```java\nimport java.util.Stack;\n\nclass ColaConPilas {\n    Stack<Integer> s1 = new Stack<>();\n    Stack<Integer> s2 = new Stack<>();\n\n    void enqueue(int x) { s1.push(x); }\n    \n    int dequeue() {\n        if (s2.isEmpty()) {\n            while (!s1.isEmpty()) s2.push(s1.pop());\n        }\n        return s2.pop();\n    }\n}```"}
{"instruction": "Intercambia dos variables enteras sin usar una variable temporal (XOR Swap).", "response": "Truco de bajo nivel usando la propiedad del XOR (`^`).\n\n```java\npublic void swapXOR(int a, int b) {\n    // Suponiendo a=5, b=7\n    a = a ^ b;\n    b = a ^ b;\n    a = a ^ b;\n    System.out.println(\"a: \" + a + \", b: \" + b);\n}```"}
{"instruction": "Explica el uso de la palabra clave 'volatile'.", "response": "Garantiza que el valor de la variable sea leído siempre desde la memoria principal, no desde la caché del CPU (visibilidad entre hilos).\n\n```java\nclass Flag {\n    volatile boolean running = true;\n    \n    void detener() { running = false; }\n    void run() {\n        while (running) { /* proceso */ }\n    }\n}```"}
{"instruction": "Implementa el patrón Singleton básico.", "response": "Asegura que una clase tenga una única instancia en toda la aplicación.\n\n```java\npublic class Singleton {\n    private static final Singleton instancia = new Singleton();\n    \n    private Singleton() {} // Constructor privado\n    \n    public static Singleton getInstancia() {\n        return instancia;\n    }\n}```"}
{"instruction": "Usa 'super' para llamar al constructor de la clase padre.", "response": "Debe ser la primera línea en el constructor de la clase hija.\n\n```java\nclass Padre {\n    Padre(String msg) { System.out.println(msg); }\n}\n\nclass Hijo extends Padre {\n    Hijo() {\n        super(\"Llamando al padre\");\n    }\n}```"}
{"instruction": "Usa 'this' para llamar a otro constructor de la misma clase.", "response": "Permite reutilizar lógica de inicialización (Constructor chaining).\n\n```java\nclass Rectangulo {\n    int x, y;\n    Rectangulo() {\n        this(0, 0); // Llama al constructor con argumentos\n    }\n    Rectangulo(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n}```"}
{"instruction": "Verifica el tipo de un objeto usando 'instanceof'.", "response": "Útil antes de hacer un casting explícito para evitar `ClassCastException`.\n\n```java\npublic void verificar(Object obj) {\n    if (obj instanceof String) {\n        String s = (String) obj;\n        System.out.println(\"Es un texto de largo: \" + s.length());\n    }\n}```"}
{"instruction": "Invierte un String usando StringBuilder (Forma eficiente).", "response": "`StringBuilder` es mutable y tiene un método `reverse()` optimizado.\n\n```java\npublic String invertirRapido(String s) {\n    return new StringBuilder(s).reverse().toString();\n}```"}
{"instruction": "Explica la ineficiencia de concatenar Strings en un bucle.", "response": "Strings son inmutables; concatenar en bucle crea O(n) objetos temporales, resultando en O(n^2). Usa StringBuilder.\n\n```java\npublic String malo(int n) {\n    String s = \"\";\n    for(int i=0; i<n; i++) s += i; // Ineficiente\n    return s;\n}\n\npublic String bueno(int n) {\n    StringBuilder sb = new StringBuilder();\n    for(int i=0; i<n; i++) sb.append(i); // Eficiente\n    return sb.toString();\n}```"}
{"instruction": "Usa EnumSet para trabajar con conjuntos de Enums eficientemente.", "response": "`EnumSet` usa vectores de bits internamente, siendo muy rápido y compacto.\n\n```java\nimport java.util.EnumSet;\n\nenum Dia { LUN, MAR, MIE, JUE, VIE }\n\npublic class DiasHabiles {\n    public static void main(String[] args) {\n        EnumSet<Dia> trabajo = EnumSet.range(Dia.LUN, Dia.VIE);\n        System.out.println(trabajo.contains(Dia.MAR)); // true\n    }\n}```"}
{"instruction": "Explica IdentityHashMap y su diferencia con HashMap.", "response": "`IdentityHashMap` usa igualdad de referencia (`==`) en lugar de igualdad de objeto (`equals`) para las claves.\n\n```java\nimport java.util.IdentityHashMap;\n\npublic class Identidad {\n    public static void main(String[] args) {\n        IdentityHashMap<String, Integer> map = new IdentityHashMap<>();\n        String k1 = new String(\"A\");\n        String k2 = new String(\"A\");\n        map.put(k1, 1);\n        map.put(k2, 2);\n        System.out.println(map.size()); // 2 (porque k1 != k2 en memoria)\n    }\n}```"}
{"instruction": "Realiza una copia profunda (Deep Copy) manualmente.", "response": "Necesario cuando el objeto contiene referencias a otros objetos mutables.\n\n```java\nclass Punto { int x, y; }\nclass Caja {\n    Punto p;\n    Caja(Punto p) { this.p = p; }\n    Caja copiar() {\n        Punto nuevoP = new Punto();\n        nuevoP.x = this.p.x;\n        nuevoP.y = this.p.y;\n        return new Caja(nuevoP);\n    }\n}```"}
{"instruction": "Explica los Tipos de Retorno Covariantes.", "response": "Una clase hija puede sobrescribir un método devolviendo una subclase del tipo de retorno original.\n\n```java\nclass A { A get() { return this; } }\n\nclass B extends A {\n    @Override\n    B get() { return this; } // Devuelve B, que es subtipo de A\n}```"}
{"instruction": "Diferencia entre Checked y Unchecked Exceptions.", "response": "Checked (ej. IOException) obligan a try-catch. Unchecked (RuntimeException) no.\n\n```java\nimport java.io.*;\n// Checked: el compilador se queja si no la manejas\npublic void leer() throws IOException {\n    throw new IOException(\"Archivo no encontrado\");\n}\n// Unchecked: el compilador no obliga a declararla\npublic void dividir() {\n    throw new ArithmeticException(\"Error mate\");\n}```"}
{"instruction": "Explica la palabra clave 'transient' en serialización.", "response": "Evita que un campo sea serializado (guardado) cuando se convierte el objeto a bytes.\n\n```java\nimport java.io.Serializable;\n\nclass Usuario implements Serializable {\n    String nombre;\n    transient String password; // No se guardará en archivo\n}```"}
{"instruction": "Usa un Bloque Inicializador de Instancia.", "response": "Bloque de código que se ejecuta antes del constructor cada vez que se crea un objeto.\n\n```java\npublic class BloqueInit {\n    {\n        System.out.println(\"Bloque ejecutado\");\n    }\n    public BloqueInit() {\n        System.out.println(\"Constructor ejecutado\");\n    }\n}```"}
{"instruction": "Utiliza Varargs (Argumentos variables) en un método.", "response": "Permite pasar un número arbitrario de argumentos del mismo tipo.\n\n```java\npublic void imprimirVarios(String... textos) {\n    for (String t : textos) {\n        System.out.println(t);\n    }\n}\n// Uso: imprimirVarios(\"A\", \"B\", \"C\");```"}
{"instruction": "Compara Strings correctamente usando equals() vs ==.", "response": "`==` compara referencias de memoria, `equals()` compara el contenido del texto.\n\n```java\npublic void comparar() {\n    String s1 = new String(\"Hola\");\n    String s2 = new String(\"Hola\");\n    System.out.println(s1 == s2);      // false\n    System.out.println(s1.equals(s2)); // true\n}```"}
{"instruction": "Rellena un arreglo con un valor predeterminado usando Arrays.fill().", "response": "Forma rápida de inicializar o resetear un arreglo.\n\n```java\nimport java.util.Arrays;\n\npublic class Rellenar {\n    public static void main(String[] args) {\n        int[] arr = new int[5];\n        Arrays.fill(arr, 9);\n        System.out.println(Arrays.toString(arr)); // [9, 9, 9, 9, 9]\n    }\n}```"}
{"instruction": "Encuentra el elemento máximo de una colección con Collections.max().", "response": "Funciona con cualquier colección que contenga elementos comparables.\n\n```java\nimport java.util.*;\n\npublic class MaxColeccion {\n    public static void main(String[] args) {\n        List<Integer> nums = Arrays.asList(5, 12, 3);\n        System.out.println(Collections.max(nums)); // 12\n    }\n}```"}
{"instruction": "Crea una vista de una parte de la lista usando subList().", "response": "`subList` retorna una vista respaldada por la lista original (cambios en una afectan a la otra).\n\n```java\nimport java.util.*;\npublic class SubLista {\n    public static void main(String[] args) {\n        List<String> l = new ArrayList<>(Arrays.asList(\"A\", \"B\", \"C\", \"D\"));\n        List<String> sub = l.subList(1, 3); // B, C\n        sub.set(0, \"Z\");\n        System.out.println(l); // [A, Z, C, D]\n    }\n}```"}
{"instruction": "Calcula la transpuesta de una matriz cuadrada.", "response": "Intercambia filas por columnas.\n\n```java\npublic void transponer(int[][] matriz) {\n    int n = matriz.length;\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            int temp = matriz[i][j];\n            matriz[i][j] = matriz[j][i];\n            matriz[j][i] = temp;\n        }\n    }\n}```"}
{"instruction": "Suma los elementos de la diagonal principal de una matriz.", "response": "La diagonal principal son los elementos donde `i == j`. Complejidad O(n).\n\n```java\npublic int sumaDiagonal(int[][] matriz) {\n    int suma = 0;\n    for (int i = 0; i < matriz.length; i++) {\n        suma += matriz[i][i];\n    }\n    return suma;\n}```"}
{"instruction": "Copia un rango de un arreglo a otro usando System.arraycopy().", "response": "Es un método nativo muy rápido para copiar bloques de memoria.\n\n```java\npublic class CopiaNativa {\n    public static void main(String[] args) {\n        int[] origen = {1, 2, 3, 4, 5};\n        int[] destino = new int[3];\n        // Copia desde índice 1, 3 elementos\n        System.arraycopy(origen, 1, destino, 0, 3);\n        // destino es {2, 3, 4}\n    }\n}```"}
{"instruction": "Convierte un String numérico a entero (Parse).", "response": "`Integer.parseInt` lanza `NumberFormatException` si el formato no es válido.\n\n```java\npublic int convertir(String s) {\n    try {\n        return Integer.parseInt(s);\n    } catch (NumberFormatException e) {\n        return 0; // Valor por defecto\n    }\n}```"}
{"instruction": "Verifica si un carácter es un dígito.", "response": "Uso de la clase envolvente `Character`.\n\n```java\npublic boolean tieneDigito(String s) {\n    for (char c : s.toCharArray()) {\n        if (Character.isDigit(c)) return true;\n    }\n    return false;\n}```"}
{"instruction": "Divide una cadena en partes usando split().", "response": "Usa expresiones regulares para delimitar.\n\n```java\npublic void separarPalabras(String frase) {\n    String[] palabras = frase.split(\" \");\n    for (String p : palabras) System.out.println(p);\n}```"}
{"instruction": "Define un Método Genérico.", "response": "Permite que un método acepte argumentos de tipos variables.\n\n```java\npublic <T> void imprimirArray(T[] array) {\n    for (T elemento : array) {\n        System.out.println(elemento);\n    }\n}```"}
{"instruction": "Usa Wildcards (Comodines) acotados en Generics.", "response": "`? extends Number` permite leer números pero restringe la escritura.\n\n```java\nimport java.util.List;\npublic double sumarLista(List<? extends Number> lista) {\n    double suma = 0;\n    for (Number n : lista) suma += n.doubleValue();\n    return suma;\n}```"}
{"instruction": "Pausa la ejecución del hilo actual con Thread.sleep().", "response": "Útil para simular esperas, requiere manejar `InterruptedException`.\n\n```java\npublic void esperar() {\n    try {\n        System.out.println(\"Durmiendo...\");\n        Thread.sleep(1000); // 1 segundo\n        System.out.println(\"Despierto\");\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n}```"}
{"instruction": "Crea un hilo usando una expresión Lambda (Runnable).", "response": "Forma moderna y concisa de iniciar hilos.\n\n```java\npublic class HiloLambda {\n    public static void main(String[] args) {\n        Thread t = new Thread(() -> System.out.println(\"Hilo corriendo\"));\n        t.start();\n    }\n}```"}
{"instruction": "Mide el tiempo de ejecución de un código con System.nanoTime().", "response": "Más preciso que `currentTimeMillis` para benchmarking.\n\n```java\npublic void medir() {\n    long inicio = System.nanoTime();\n    // Tarea pesada\n    long fin = System.nanoTime();\n    System.out.println(\"Duración (ns): \" + (fin - inicio));\n}```"}
{"instruction": "Compara el contenido de dos arreglos usando Arrays.equals().", "response": "`a == b` solo compara referencias. `Arrays.equals` compara el contenido.\n\n```java\nimport java.util.Arrays;\npublic boolean sonIguales(int[] a, int[] b) {\n    return Arrays.equals(a, b);\n}```"}
{"instruction": "Explica String.intern() para optimización de memoria.", "response": "Mueve el String al pool de cadenas, permitiendo comparar con `==` y ahorrando RAM.\n\n```java\npublic void internalizar() {\n    String s1 = new String(\"Hola\").intern();\n    String s2 = \"Hola\";\n    System.out.println(s1 == s2); // true\n}```"}
{"instruction": "Genera un número aleatorio en un rango.", "response": "Usando `Math.random()` que devuelve un double entre 0.0 y 1.0.\n\n```java\n// Generar entero entre min y max\npublic int aleatorio(int min, int max) {\n    return (int) (Math.random() * (max - min + 1) + min);\n}```"}
{"instruction": "Usa el Operador Ternario para simplificar un if-else.", "response": "Sintaxis: `condicion ? valor_si_true : valor_si_false`.\n\n```java\npublic String verificarAprobado(int nota) {\n    return (nota >= 6) ? \"Aprobado\" : \"Reprobado\";\n}```"}
{"instruction": "Usa 'break' con etiqueta para salir de bucles anidados.", "response": "Permite romper el bucle externo desde dentro del interno.\n\n```java\npublic void buscarEnMatriz(int[][] m, int target) {\n    externo:\n    for (int i = 0; i < m.length; i++) {\n        for (int j = 0; j < m[i].length; j++) {\n            if (m[i][j] == target) {\n                System.out.println(\"Encontrado\");\n                break externo;\n            }\n        }\n    }\n}```"}
{"instruction": "Usa 'continue' para saltar una iteración.", "response": "Salta el resto del código en el bucle y pasa a la siguiente vuelta.\n\n```java\npublic void imprimirImpares(int n) {\n    for (int i = 0; i < n; i++) {\n        if (i % 2 == 0) continue; // Salta pares\n        System.out.println(i);\n    }\n}```"}
{"instruction": "Implementa un bucle do-while.", "response": "Garantiza que el bloque se ejecute al menos una vez antes de evaluar la condición.\n\n```java\npublic void ejecutarAlMenosUnaVez() {\n    int contador = 0;\n    do {\n        System.out.println(\"Ejecutando: \" + contador);\n        contador++;\n    } while (contador < 5);\n}```"}
{"instruction": "Muestra el uso básico de Optional para evitar NullPointerException.", "response": "`Optional` es un contenedor que puede o no contener un valor no nulo.\n\n```java\nimport java.util.Optional;\npublic void saludar(String nombre) {\n    Optional<String> opt = Optional.ofNullable(nombre);\n    System.out.println(opt.orElse(\"Invitado\"));\n}```"}
{"instruction": "Filtra una lista usando Streams (Java 8).", "response": "Programación funcional para procesar colecciones.\n\n```java\nimport java.util.*;\nimport java.util.stream.Collectors;\n\npublic class StreamFilter {\n    public static void main(String[] args) {\n        List<Integer> nums = Arrays.asList(1, 2, 3, 4, 5);\n        List<Integer> pares = nums.stream()\n                                  .filter(n -> n % 2 == 0)\n                                  .collect(Collectors.toList());\n        System.out.println(pares); // [2, 4]\n    }\n}```"}
{"instruction": "Transforma elementos de una lista usando Streams (Map).", "response": "`map` aplica una función a cada elemento del stream.\n\n```java\nimport java.util.*;\nimport java.util.stream.Collectors;\n\npublic class StreamMap {\n    public static void main(String[] args) {\n        List<String> nombres = Arrays.asList(\"a\", \"b\");\n        List<String> mayus = nombres.stream()\n                                    .map(String::toUpperCase)\n                                    .collect(Collectors.toList());\n        System.out.println(mayus); // [A, B]\n    }\n}```"}
{"instruction": "Explica el concepto de grafos con un ejemplo en Java.", "response": "En Java, los grafos se implementan utilizando estructuras nativas o clases personalizadas. Aquí tienes un ejemplo simple en Java relacionado con grafos.\n\n```java\nimport java.util.*;\n\npublic class GrafoBasico {\n    Map<Integer, List<Integer>> adjacencia = new HashMap<>();\n    \n    void agregarArista(int origen, int destino) {\n        adjacencia.computeIfAbsent(origen, k -> new ArrayList<>()).add(destino);\n    }\n    \n    public static void main(String[] args) {\n        GrafoBasico g = new GrafoBasico();\n        g.agregarArista(1, 2);\n        g.agregarArista(1, 3);\n        System.out.println(\"Vecinos de 1: \" + g.adjacencia.get(1));\n    }\n}```"}
{"instruction": "Usa Stream reduce() para sumar una lista de números.", "response": "La operación `reduce` combina todos los elementos del stream en un solo resultado.\n\n```java\nimport java.util.*;\n\npublic class SumaReduce {\n    public static void main(String[] args) {\n        List<Integer> numeros = Arrays.asList(1, 2, 3, 4);\n        int suma = numeros.stream().reduce(0, Integer::sum);\n        System.out.println(suma); // 10\n    }\n}```"}
{"instruction": "Verifica si algún elemento cumple una condición con anyMatch() en Streams.", "response": "`anyMatch` retorna `true` si al menos un elemento satisface el predicado. Es una operación de corto circuito.\n\n```java\nimport java.util.*;\n\npublic class ExisteElemento {\n    public static void main(String[] args) {\n        List<String> nombres = Arrays.asList(\"Ana\", \"Pedro\", \"Luis\");\n        boolean hayConL = nombres.stream().anyMatch(s -> s.startsWith(\"L\"));\n        System.out.println(hayConL); // true\n    }\n}```"}
{"instruction": "Obtén la fecha actual usando la API moderna LocalDate (Java 8).", "response": "`LocalDate` es inmutable y thread-safe, reemplazando a la antigua `java.util.Date` para fechas sin hora.\n\n```java\nimport java.time.LocalDate;\n\npublic class FechaHoy {\n    public static void main(String[] args) {\n        LocalDate hoy = LocalDate.now();\n        System.out.println(\"Hoy es: \" + hoy);\n        System.out.println(\"Mañana será: \" + hoy.plusDays(1));\n    }\n}```"}
{"instruction": "Calcula la diferencia de tiempo entre dos instantes con Duration.", "response": "`Duration` mide el tiempo en segundos y nanosegundos entre dos objetos `Instant`.\n\n```java\nimport java.time.Duration;\nimport java.time.Instant;\n\npublic class Cronometro {\n    public static void main(String[] args) throws InterruptedException {\n        Instant inicio = Instant.now();\n        Thread.sleep(100); // Simular proceso\n        Instant fin = Instant.now();\n        System.out.println(Duration.between(inicio, fin).toMillis() + \" ms\");\n    }\n}```"}
{"instruction": "Lee todas las líneas de un archivo de texto usando NIO (Files).", "response": "`Files.readAllLines` es una forma sencilla de cargar un archivo pequeño en memoria.\n\n```java\nimport java.nio.file.*;\nimport java.io.IOException;\nimport java.util.List;\n\npublic class LeerNIO {\n    public static void leer(String ruta) throws IOException {\n        Path path = Paths.get(ruta);\n        List<String> lineas = Files.readAllLines(path);\n        lineas.forEach(System.out::println);\n    }\n}```"}
{"instruction": "Escribe contenido en un archivo usando NIO.", "response": "`Files.write` permite crear o sobrescribir archivos fácilmente.\n\n```java\nimport java.nio.file.*;\nimport java.util.Arrays;\n\npublic class EscribirNIO {\n    public static void main(String[] args) throws Exception {\n        Path path = Paths.get(\"nota.txt\");\n        Files.write(path, Arrays.asList(\"Línea 1\", \"Línea 2\"));\n    }\n}```"}
{"instruction": "Define y utiliza una Clase Interna (Inner Class) no estática.", "response": "Una clase interna tiene acceso a los miembros de la clase externa, incluso los privados. Requiere una instancia de la externa.\n\n```java\nclass Externa {\n    private String secreto = \"Clave\";\n    class Interna {\n        void revelar() { System.out.println(secreto); }\n    }\n}\n// Uso: new Externa().new Interna().revelar();```"}
{"instruction": "Define y utiliza una Clase Anidada Estática (Static Nested Class).", "response": "Funciona como una clase normal pero empaquetada dentro de otra. No tiene acceso directo a miembros de instancia de la externa.\n\n```java\nclass Externa {\n    static class Anidada {\n        void saludar() { System.out.println(\"Hola desde static nested\"); }\n    }\n}\n// Uso: new Externa.Anidada().saludar();```"}
{"instruction": "Usa Reflexión (Reflection) para obtener los métodos de una clase.", "response": "Permite inspeccionar el código en tiempo de ejecución. Útil para frameworks y herramientas.\n\n```java\nimport java.lang.reflect.Method;\n\npublic class ReflexionDemo {\n    public static void main(String[] args) {\n        Method[] metodos = String.class.getDeclaredMethods();\n        System.out.println(\"String tiene \" + metodos.length + \" métodos declarados.\");\n    }\n}```"}
{"instruction": "Usa AtomicInteger para contadores seguros en hilos.", "response": "Evita condiciones de carrera sin necesidad de `synchronized` explícito.\n\n```java\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class ContadorAtomico {\n    public static void main(String[] args) {\n        AtomicInteger contador = new AtomicInteger(0);\n        System.out.println(contador.incrementAndGet()); // 1\n        System.out.println(contador.addAndGet(5));      // 6\n    }\n}```"}
{"instruction": "Ejecuta tareas asíncronas con ExecutorService (Pool de hilos).", "response": "Administra un conjunto de hilos reutilizables, más eficiente que crear hilos manualmente.\n\n```java\nimport java.util.concurrent.*;\n\npublic class PoolHilos {\n    public static void main(String[] args) {\n        ExecutorService executor = Executors.newFixedThreadPool(2);\n        executor.submit(() -> System.out.println(\"Tarea 1\"));\n        executor.shutdown();\n    }\n}```"}
{"instruction": "Obtén el resultado de una tarea futura con Callable y Future.", "response": "A diferencia de `Runnable`, `Callable` puede devolver un valor y lanzar excepciones.\n\n```java\nimport java.util.concurrent.*;\n\npublic class FuturoEjemplo {\n    public static void main(String[] args) throws Exception {\n        ExecutorService ex = Executors.newSingleThreadExecutor();\n        Future<Integer> futuro = ex.submit(() -> 10 * 10);\n        System.out.println(futuro.get()); // 100\n        ex.shutdown();\n    }\n}```"}
{"instruction": "Sincroniza hilos usando CountDownLatch.", "response": "Permite que uno o más hilos esperen hasta que un conjunto de operaciones en otros hilos se complete.\n\n```java\nimport java.util.concurrent.CountDownLatch;\n\npublic class LatchDemo {\n    public static void main(String[] args) throws InterruptedException {\n        CountDownLatch latch = new CountDownLatch(3);\n        // Imagina 3 hilos haciendo latch.countDown()\n        latch.await(); // Espera a que el contador llegue a 0\n        System.out.println(\"Todos listos\");\n    }\n}```"}
{"instruction": "Une elementos de una lista en un String con String.join().", "response": "Método estático conveniente para concatenar colecciones con un delimitador.\n\n```java\nimport java.util.Arrays;\n\npublic class UnirStrings {\n    public static void main(String[] args) {\n        String resultado = String.join(\" - \", \"Java\", \"Python\", \"C++\");\n        System.out.println(resultado); // Java - Python - C++\n    }\n}```"}
{"instruction": "Formatea cadenas usando String.format().", "response": "Permite crear strings con marcadores de posición, similar a `printf` en C.\n\n```java\npublic class Formato {\n    public static void main(String[] args) {\n        String s = String.format(\"Hola %s, tienes %d mensajes\", \"Usuario\", 5);\n        System.out.println(s);\n    }\n}```"}
{"instruction": "Verifica si dos cadenas son anagramas (usando ordenamiento).", "response": "Si se ordenan los caracteres de ambas cadenas y son iguales, entonces son anagramas.\n\n```java\nimport java.util.Arrays;\n\npublic boolean esAnagrama(String s1, String s2) {\n    char[] c1 = s1.toCharArray();\n    char[] c2 = s2.toCharArray();\n    Arrays.sort(c1);\n    Arrays.sort(c2);\n    return Arrays.equals(c1, c2);\n}```"}
{"instruction": "Comprueba si un número es Armstrong (Suma de cubos de dígitos).", "response": "Ejemplo: 153 = 1^3 + 5^3 + 3^3.\n\n```java\npublic boolean esArmstrong(int n) {\n    int original = n, suma = 0;\n    while (n > 0) {\n        int digito = n % 10;\n        suma += digito * digito * digito;\n        n /= 10;\n    }\n    return suma == original;\n}```"}
{"instruction": "Rota un arreglo hacia la derecha k veces.", "response": "Mueve los elementos circularmente.\n\n```java\npublic void rotarDerecha(int[] nums, int k) {\n    int n = nums.length;\n    k = k % n; // Optimización\n    int[] resultado = new int[n];\n    for (int i = 0; i < n; i++) {\n        resultado[(i + k) % n] = nums[i];\n    }\n    // Copiar de vuelta si se requiere in-place\n}```"}
{"instruction": "Mueve todos los ceros de un arreglo al final.", "response": "Algoritmo de dos punteros para mantener el orden relativo de los no ceros.\n\n```java\npublic void moverCeros(int[] nums) {\n    int pos = 0;\n    for (int num : nums) {\n        if (num != 0) nums[pos++] = num;\n    }\n    while (pos < nums.length) nums[pos++] = 0;\n}```"}
{"instruction": "Encuentra el segundo número más grande de un arreglo.", "response": "Se puede hacer en una sola pasada manteniendo dos variables.\n\n```java\npublic int segundoMayor(int[] nums) {\n    int max = Integer.MIN_VALUE, segundo = Integer.MIN_VALUE;\n    for (int n : nums) {\n        if (n > max) {\n            segundo = max;\n            max = n;\n        } else if (n > segundo && n != max) {\n            segundo = n;\n        }\n    }\n    return segundo;\n}```"}
{"instruction": "Usa las nuevas Expresiones Switch (Java 12+).", "response": "Sintaxis más limpia que devuelve valor y no necesita `break`.\n\n```java\npublic String tipoDia(int dia) {\n    return switch (dia) {\n        case 1, 7 -> \"Fin de semana\";\n        case 2, 3, 4, 5, 6 -> \"Día laboral\";\n        default -> \"Inválido\";\n    };\n}```"}
{"instruction": "Define un Record (Java 14+) para almacenar datos inmutables.", "response": "Los `records` eliminan el boilerplate (getters, toString, equals, hashCode).\n\n```java\npublic record Punto(int x, int y) {}\n\n// Uso:\n// Punto p = new Punto(10, 20);\n// System.out.println(p.x());```"}
{"instruction": "Usa Text Blocks (Java 15+) para cadenas multilínea.", "response": "Facilita la escritura de JSON, SQL o HTML dentro de Java.\n\n```java\nString json = \"\"\"\n    {\n        \"nombre\": \"Java\",\n        \"version\": 21\n    }\n    \"\"\";```"}
{"instruction": "Crea listas inmutables con List.of() (Java 9).", "response": "Forma concisa de crear listas fijas. No permiten nulls ni modificaciones.\n\n```java\nimport java.util.List;\n\npublic class ListaInmutable {\n    public static void main(String[] args) {\n        List<String> frutas = List.of(\"Manzana\", \"Pera\");\n        // frutas.add(\"Uva\"); // Lanza UnsupportedOperationException\n    }\n}```"}
{"instruction": "Usa ConcurrentHashMap para mapas thread-safe de alto rendimiento.", "response": "Permite lecturas concurrentes sin bloqueo y escrituras segmentadas.\n\n```java\nimport java.util.concurrent.ConcurrentHashMap;\n\npublic class MapaConcurrente {\n    public static void main(String[] args) {\n        ConcurrentHashMap<String, Integer> map = new ConcurrentHashMap<>();\n        map.put(\"Key\", 1);\n        // Operaciones atómicas disponibles\n        map.computeIfPresent(\"Key\", (k, v) -> v + 1);\n    }\n}```"}
{"instruction": "Almacena datos específicos por hilo con ThreadLocal.", "response": "Cada hilo ve su propia copia de la variable, útil para transacciones o contextos de usuario.\n\n```java\npublic class ContextoHilo {\n    static ThreadLocal<String> usuarioId = ThreadLocal.withInitial(() -> \"Desconocido\");\n\n    public static void main(String[] args) {\n        usuarioId.set(\"User123\");\n        System.out.println(usuarioId.get()); // User123\n    }\n}```"}
{"instruction": "Registra un Shutdown Hook para ejecutar código al cerrar la JVM.", "response": "Útil para liberar recursos o guardar estado cuando el programa termina.\n\n```java\npublic class CierreApp {\n    public static void main(String[] args) {\n        Runtime.getRuntime().addShutdownHook(new Thread(() -> {\n            System.out.println(\"Limpiando y cerrando...\");\n        }));\n    }\n}```"}
{"instruction": "Usa Math.pow() y Math.sqrt() para cálculos matemáticos.", "response": "Clase utilitaria estática para operaciones matemáticas comunes.\n\n```java\npublic double hipotenusa(double a, double b) {\n    return Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2));\n}```"}
{"instruction": "Termina la ejecución del programa con System.exit().", "response": "Detiene la JVM. Un código distinto de 0 indica error.\n\n```java\npublic void verificarCritico(boolean error) {\n    if (error) {\n        System.err.println(\"Error fatal\");\n        System.exit(1);\n    }\n}```"}
{"instruction": "Usa 'assert' para depuración y verificación de invariantes.", "response": "Se activan con la bandera `-ea` en la JVM. Si la condición es falsa, lanza `AssertionError`.\n\n```java\npublic void procesarEdad(int edad) {\n    assert edad >= 0 : \"La edad no puede ser negativa\";\n    System.out.println(\"Edad: \" + edad);\n}```"}
{"instruction": "Elimina elementos de una colección seguramente con Iterator.remove().", "response": "Modificar una colección en un bucle for-each lanza `ConcurrentModificationException`, el iterador lo previene.\n\n```java\nimport java.util.*;\n\npublic void limpiar(List<String> lista) {\n    Iterator<String> it = lista.iterator();\n    while(it.hasNext()) {\n        if(it.next().isEmpty()) it.remove();\n    }\n}```"}
{"instruction": "Itera una lista hacia atrás usando ListIterator.", "response": "`ListIterator` permite recorrer en ambas direcciones y modificar la lista durante el recorrido.\n\n```java\nimport java.util.*;\n\npublic class Reverso {\n    public static void main(String[] args) {\n        List<String> l = Arrays.asList(\"A\", \"B\");\n        ListIterator<String> it = l.listIterator(l.size());\n        while(it.hasPrevious()) {\n            System.out.println(it.previous());\n        }\n    }\n}```"}
{"instruction": "Usa BigDecimal para operaciones financieras precisas.", "response": "Los tipos `double` y `float` tienen errores de redondeo. `BigDecimal` es exacto.\n\n```java\nimport java.math.BigDecimal;\n\npublic class Dinero {\n    public static void main(String[] args) {\n        BigDecimal a = new BigDecimal(\"0.1\");\n        BigDecimal b = new BigDecimal(\"0.2\");\n        System.out.println(a.add(b)); // 0.3 exacto\n    }\n}```"}
{"instruction": "Calcula el factorial de números grandes con BigInteger.", "response": "`int` y `long` se desbordan rápidamente con factoriales. `BigInteger` no tiene límite teórico.\n\n```java\nimport java.math.BigInteger;\n\npublic BigInteger factorial(int n) {\n    BigInteger f = BigInteger.ONE;\n    for (int i = 2; i <= n; i++)\n        f = f.multiply(BigInteger.valueOf(i));\n    return f;\n}```"}
{"instruction": "Lee entrada del usuario desde la consola con Scanner.", "response": "Clase estándar para parsear tipos primitivos y cadenas desde flujos de entrada.\n\n```java\nimport java.util.Scanner;\n\npublic class Entrada {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        System.out.print(\"Ingresa un número: \");\n        if (sc.hasNextInt()) {\n            int n = sc.nextInt();\n            System.out.println(\"Leído: \" + n);\n        }\n    }\n}```"}
{"instruction": "Desordena (baraja) una lista aleatoriamente con Collections.shuffle().", "response": "Útil para juegos de azar o pruebas aleatorias.\n\n```java\nimport java.util.*;\n\npublic class Baraja {\n    public static void main(String[] args) {\n        List<Integer> cartas = Arrays.asList(1, 2, 3, 4, 5);\n        Collections.shuffle(cartas);\n        System.out.println(cartas);\n    }\n}```"}
{"instruction": "Cuenta las ocurrencias de un elemento en una colección con frequency().", "response": "Método utilitario para contar repeticiones sin bucles manuales.\n\n```java\nimport java.util.*;\n\npublic class Conteo {\n    public static void main(String[] args) {\n        List<String> items = Arrays.asList(\"A\", \"B\", \"A\");\n        System.out.println(Collections.frequency(items, \"A\")); // 2\n    }\n}```"}
{"instruction": "Crea una interfaz funcional personalizada que no retorne valor (Consumer-like).", "response": "Definir interfaces propias permite desacoplar lógica.\n\n```java\n@FunctionalInterface\ninterface Procesador {\n    void procesar(String dato);\n}\n\npublic class Test {\n    public void ejecutar(Procesador p) { p.procesar(\"Dato\"); }\n}```"}
{"instruction": "Explica el patrón Builder para construir objetos complejos.", "response": "Permite crear objetos paso a paso, ideal cuando hay muchos parámetros opcionales.\n\n```java\nclass Pizza {\n    String masa; boolean queso;\n    // Constructor privado\n    private Pizza(Builder b) { this.masa = b.masa; this.queso = b.queso; }\n    \n    static class Builder {\n        String masa; boolean queso;\n        Builder conMasa(String m) { masa = m; return this; }\n        Builder conQueso() { queso = true; return this; }\n        Pizza build() { return new Pizza(this); }\n    }\n}```"}
{"instruction": "Usa el método computeIfAbsent en un Map.", "response": "Calcula el valor solo si la clave no está presente, y lo inserta.\n\n```java\nimport java.util.*;\n\npublic class CacheSimple {\n    public static void main(String[] args) {\n        Map<String, List<String>> multiMap = new HashMap<>();\n        // Crea la lista si no existe y luego agrega \"Valor\"\n        multiMap.computeIfAbsent(\"Grupo1\", k -> new ArrayList<>()).add(\"Valor\");\n    }\n}```"}
{"instruction": "Combina dos conjuntos (Set) para obtener la Unión.", "response": "`addAll` agrega todos los elementos, resultando en la unión matemática.\n\n```java\nimport java.util.*;\n\npublic class UnionSets {\n    public static void main(String[] args) {\n        Set<Integer> a = new HashSet<>(Arrays.asList(1, 2));\n        Set<Integer> b = new HashSet<>(Arrays.asList(2, 3));\n        a.addAll(b);\n        System.out.println(a); // [1, 2, 3]\n    }\n}```"}
{"instruction": "Obtén la diferencia entre dos conjuntos (Set).", "response": "`removeAll` elimina los elementos que están en la otra colección.\n\n```java\nimport java.util.*;\n\npublic class DiferenciaSets {\n    public static void main(String[] args) {\n        Set<Integer> a = new HashSet<>(Arrays.asList(1, 2, 3));\n        Set<Integer> b = new HashSet<>(Arrays.asList(2));\n        a.removeAll(b);\n        System.out.println(a); // [1, 3]\n    }\n}```"}
{"instruction": "Verifica si un número es Double.NaN (Not a Number).", "response": "Comparar `x == Double.NaN` siempre es falso. Se debe usar el método estático.\n\n```java\npublic void checarNaN(double valor) {\n    if (Double.isNaN(valor)) {\n        System.out.println(\"Resultado inválido\");\n    }\n}```"}
{"instruction": "Implementa la interfaz Cloneable (Copia superficial estándar).", "response": "Interfaz marcador para permitir el uso del método `clone()` de `Object`.\n\n```java\nclass Perro implements Cloneable {\n    String nombre;\n    public Perro(String n) { nombre = n; }\n    @Override\n    protected Object clone() throws CloneNotSupportedException {\n        return super.clone();\n    }\n}```"}
{"instruction": "Usa Pattern Matching con instanceof (Java 16+).", "response": "Evita el casting explícito después de verificar el tipo.\n\n```java\npublic void procesar(Object obj) {\n    if (obj instanceof String s) {\n        // 's' ya es String aquí\n        System.out.println(s.toUpperCase());\n    }\n}```"}
{"instruction": "Agrupa elementos de una lista usando Streams y Collectors.groupingBy().", "response": "Permite agrupar objetos por una propiedad, retornando un Map<Propiedad, Lista>.\n\n```java\nimport java.util.*;\nimport java.util.stream.Collectors;\n\npublic class Agrupar {\n    public static void main(String[] args) {\n        List<String> palabras = Arrays.asList(\"Ana\", \"Bob\", \"Ali\");\n        Map<Integer, List<String>> porLongitud = palabras.stream()\n            .collect(Collectors.groupingBy(String::length));\n        System.out.println(porLongitud);\n        // {3=[Ana, Bob, Ali]}\n    }\n}```"}
{"instruction": "Aplana listas anidadas usando Stream flatMap().", "response": "`flatMap` transforma cada elemento en un stream y los concatena en uno solo (flattening).\n\n```java\nimport java.util.*;\nimport java.util.stream.Collectors;\n\npublic class Aplanar {\n    public static void main(String[] args) {\n        List<List<Integer>> nums = Arrays.asList(\n            Arrays.asList(1, 2), Arrays.asList(3, 4)\n        );\n        List<Integer> flat = nums.stream()\n            .flatMap(Collection::stream)\n            .collect(Collectors.toList());\n        System.out.println(flat); // [1, 2, 3, 4]\n    }\n}```"}
{"instruction": "Ejecuta una tarea asíncrona y obtén su resultado con CompletableFuture.", "response": "Forma moderna de manejar asincronía sin bloquear el hilo principal hasta que sea necesario.\n\n```java\nimport java.util.concurrent.CompletableFuture;\n\npublic class FuturoModerno {\n    public static void main(String[] args) {\n        CompletableFuture.supplyAsync(() -> \"Hola\")\n            .thenApply(s -> s + \" Mundo\")\n            .thenAccept(System.out::println); // Hola Mundo\n    }\n}```"}
{"instruction": "Usa la palabra clave 'var' para inferencia de tipos local (Java 10+).", "response": "Reduce la verbosidad cuando el tipo es obvio desde el lado derecho de la asignación.\n\n```java\nimport java.util.ArrayList;\n\npublic class Inferencia {\n    public void ejemplo() {\n        var lista = new ArrayList<String>(); // Infiere ArrayList<String>\n        lista.add(\"Java\");\n        var numero = 10; // Infiere int\n    }\n}```"}
{"instruction": "Implementa el Patrón de Diseño Factory Method simple.", "response": "Centraliza la creación de objetos, desacoplando la lógica de instanciación.\n\n```java\ninterface Notificacion { void enviar(); }\nclass Email implements Notificacion { public void enviar() { System.out.println(\"Email\"); } }\nclass SMS implements Notificacion { public void enviar() { System.out.println(\"SMS\"); } }\n\nclass NotificacionFactory {\n    public static Notificacion crear(String tipo) {\n        if (tipo.equals(\"email\")) return new Email();\n        else return new SMS();\n    }\n}```"}
{"instruction": "Usa Semaphore para limitar el acceso concurrente a un recurso.", "response": "Un semáforo mantiene un conjunto de permisos; los hilos deben adquirir uno antes de continuar.\n\n```java\nimport java.util.concurrent.Semaphore;\n\npublic class ControlAcceso {\n    Semaphore semaforo = new Semaphore(2); // Solo 2 a la vez\n    public void acceder() throws InterruptedException {\n        semaforo.acquire();\n        try { /* Acceso al recurso */ } \n        finally { semaforo.release(); }\n    }\n}```"}
{"instruction": "Encuentra el subarreglo con la suma máxima (Algoritmo de Kadane).", "response": "Algoritmo eficiente O(n) para problemas de suma máxima contigua.\n\n```java\npublic int maxSubArray(int[] nums) {\n    int maxSoFar = nums[0], maxEndingHere = nums[0];\n    for (int i = 1; i < nums.length; i++) {\n        maxEndingHere = Math.max(nums[i], maxEndingHere + nums[i]);\n        maxSoFar = Math.max(maxSoFar, maxEndingHere);\n    }\n    return maxSoFar;\n}```"}
{"instruction": "Usa Pattern y Matcher para buscar con Expresiones Regulares.", "response": "Encuentra ocurrencias de patrones complejos en texto.\n\n```java\nimport java.util.regex.*;\n\npublic class RegexDemo {\n    public static void main(String[] args) {\n        Pattern p = Pattern.compile(\"\\\\d+\"); // Busca dígitos\n        Matcher m = p.matcher(\"Java 17 y 21\");\n        while(m.find()) {\n            System.out.println(m.group()); // Imprime 17 y luego 21\n        }\n    }\n}```"}
{"instruction": "Verifica si un número es potencia de dos usando manipulación de bits.", "response": "Si `n` es potencia de 2, `n` y `n-1` no comparten bits.\n\n```java\npublic boolean esPotenciaDeDos(int n) {\n    return n > 0 && (n & (n - 1)) == 0;\n}```"}
{"instruction": "Intercambia elementos en una lista con Collections.swap().", "response": "Método utilitario para intercambiar posiciones sin lógica manual.\n\n```java\nimport java.util.*;\n\npublic class Intercambio {\n    public static void main(String[] args) {\n        List<String> l = Arrays.asList(\"A\", \"B\");\n        Collections.swap(l, 0, 1);\n        System.out.println(l); // [B, A]\n    }\n}```"}
{"instruction": "Imprime una matriz multidimensional con Arrays.deepToString().", "response": "`toString()` normal imprime referencias en arrays anidados. `deepToString` imprime el contenido recursivamente.\n\n```java\nimport java.util.Arrays;\n\npublic class MatrizString {\n    public static void main(String[] args) {\n        int[][] matriz = {{1, 2}, {3, 4}};\n        System.out.println(Arrays.deepToString(matriz));\n        // [[1, 2], [3, 4]]\n    }\n}```"}
{"instruction": "Compara dos matrices multidimensionales con Arrays.deepEquals().", "response": "Verifica la igualdad estructural profunda de objetos anidados.\n\n```java\nimport java.util.Arrays;\n\npublic class MatrizIgualdad {\n    public static void main(String[] args) {\n        int[][] a = {{1}, {2}};\n        int[][] b = {{1}, {2}};\n        System.out.println(Arrays.deepEquals(a, b)); // true\n    }\n}```"}
{"instruction": "Usa ProcessBuilder para ejecutar comandos del sistema operativo.", "response": "Más flexible y seguro que `Runtime.exec` para interactuar con la shell.\n\n```java\nimport java.io.IOException;\n\npublic class Cmd {\n    public static void main(String[] args) throws IOException {\n        ProcessBuilder pb = new ProcessBuilder(\"ping\", \"google.com\");\n        pb.start(); // Inicia el proceso\n    }\n}```"}
{"instruction": "Recorre un árbol de directorios usando Files.walk().", "response": "Stream que visita recursivamente todos los archivos y carpetas desde una ruta.\n\n```java\nimport java.nio.file.*;\nimport java.io.IOException;\nimport java.util.stream.Stream;\n\npublic class ListarArchivos {\n    public static void listar(String inicio) throws IOException {\n        try (Stream<Path> paths = Files.walk(Paths.get(inicio))) {\n            paths.filter(Files::isRegularFile)\n                 .forEach(System.out::println);\n        }\n    }\n}```"}
{"instruction": "Implementa el Patrón Singleton con 'double-checked locking'.", "response": "Optimización para hacer el Singleton thread-safe y eficiente (lazy initialization).\n\n```java\npublic class SingletonSeguro {\n    private static volatile SingletonSeguro instance;\n    private SingletonSeguro() {}\n    \n    public static SingletonSeguro getInstance() {\n        if (instance == null) {\n            synchronized (SingletonSeguro.class) {\n                if (instance == null) instance = new SingletonSeguro();\n            }\n        }\n        return instance;\n    }\n}```"}
{"instruction": "Encuentra el elemento medio de una lista enlazada (Tortuga y Liebre).", "response": "Un puntero avanza 1 paso y otro 2. Cuando el rápido llega al final, el lento está en el medio.\n\n```java\npublic NodoSimple medio(NodoSimple head) {\n    NodoSimple lento = head, rapido = head;\n    while (rapido != null && rapido.siguiente != null) {\n        lento = lento.siguiente;\n        rapido = rapido.siguiente.siguiente;\n    }\n    return lento;\n}```"}
{"instruction": "Fusiona dos arreglos ordenados en uno nuevo ordenado.", "response": "Algoritmo base del Merge Sort. Complejidad O(n + m).\n\n```java\npublic int[] fusionar(int[] a, int[] b) {\n    int[] res = new int[a.length + b.length];\n    int i=0, j=0, k=0;\n    while(i < a.length && j < b.length) res[k++] = a[i] < b[j] ? a[i++] : b[j++];\n    while(i < a.length) res[k++] = a[i++];\n    while(j < b.length) res[k++] = b[j++];\n    return res;\n}```"}
{"instruction": "Validar objetos nulos con Objects.requireNonNull().", "response": "Lanza `NullPointerException` con un mensaje claro si el objeto es nulo. Estándar para validación de argumentos.\n\n```java\nimport java.util.Objects;\n\npublic class Validador {\n    public void procesar(String data) {\n        Objects.requireNonNull(data, \"La data no puede ser null\");\n        System.out.println(data.length());\n    }\n}```"}
{"instruction": "Comparar objetos seguramente con Objects.equals() evitando NullPointerException.", "response": "Maneja el caso donde uno o ambos objetos son null automáticamente.\n\n```java\nimport java.util.Objects;\n\npublic boolean compararSeguro(String a, String b) {\n    // Si a es null, a.equals(b) fallaría. Objects.equals lo maneja.\n    return Objects.equals(a, b);\n}```"}
{"instruction": "Crea y lanza una Excepción Personalizada (Custom Exception).", "response": "Extender `Exception` o `RuntimeException` para errores de dominio específico.\n\n```java\nclass FondosInsuficientesException extends Exception {\n    public FondosInsuficientesException(String msj) {\n        super(msj);\n    }\n}\n\n// throw new FondosInsuficientesException(\"Saldo bajo\");```"}
{"instruction": "Espera a que un hilo termine con join().", "response": "El hilo actual se pausa hasta que el hilo al que se llama `join` finalice su ejecución.\n\n```java\npublic void esperarHilo() throws InterruptedException {\n    Thread t = new Thread(() -> System.out.println(\"Trabajando...\"));\n    t.start();\n    t.join(); // Espera aquí\n    System.out.println(\"Hilo terminó\");\n}```"}
{"instruction": "Configura un hilo como Demonio (Daemon Thread).", "response": "Los hilos demonio no impiden que la JVM se cierre si son los únicos corriendo (ej. Garbage Collector).\n\n```java\npublic void crearDemonio() {\n    Thread t = new Thread(() -> { while(true); });\n    t.setDaemon(true);\n    t.start();\n    // La JVM terminará aunque este hilo siga en bucle infinito\n}```"}
{"instruction": "Obtén una sub-sección de un TreeMap con subMap().", "response": "Devuelve una vista de la porción del mapa cuyas claves están en el rango.\n\n```java\nimport java.util.*;\n\npublic class RangoMap {\n    public static void main(String[] args) {\n        TreeMap<Integer, String> map = new TreeMap<>();\n        map.put(1, \"A\"); map.put(3, \"B\"); map.put(5, \"C\");\n        System.out.println(map.subMap(2, 5)); // {3=B}\n    }\n}```"}
{"instruction": "Encuentra el elemento techo (ceiling) y suelo (floor) en un TreeSet.", "response": "`ceiling` >= valor, `floor` <= valor. Útil para búsquedas aproximadas.\n\n```java\nimport java.util.TreeSet;\n\npublic class Aproximacion {\n    public static void main(String[] args) {\n        TreeSet<Integer> set = new TreeSet<>(java.util.Arrays.asList(10, 30, 50));\n        System.out.println(set.floor(25));   // 10\n        System.out.println(set.ceiling(25)); // 30\n    }\n}```"}
{"instruction": "Usa LinkedHashSet para mantener elementos únicos y orden de inserción.", "response": "Combina la unicidad de Set con el orden predecible de List.\n\n```java\nimport java.util.LinkedHashSet;\n\npublic class UnicosOrdenados {\n    public static void main(String[] args) {\n        LinkedHashSet<String> set = new LinkedHashSet<>();\n        set.add(\"Uno\");\n        set.add(\"Dos\");\n        set.add(\"Uno\"); // Ignorado\n        System.out.println(set); // [Uno, Dos]\n    }\n}```"}
{"instruction": "Cuenta los bits encendidos (1s) en un entero (Population Count).", "response": "Java tiene métodos intrínsecos optimizados para operaciones de bits.\n\n```java\npublic int contarBits(int n) {\n    return Integer.bitCount(n);\n}```"}
{"instruction": "Desplaza bits a la izquierda (<<) para multiplicar por potencias de 2.", "response": "`x << n` es equivalente a `x * 2^n`.\n\n```java\npublic int multiplicarPorOcho(int n) {\n    return n << 3; // n * 2^3 (8)\n}```"}
{"instruction": "Diferencia entre desplazamiento derecha (>>) y desplazamiento sin signo (>>>).", "response": "`>>` mantiene el signo (rellena con 1s si es negativo), `>>>` rellena con 0s siempre.\n\n```java\npublic void desplazamientos() {\n    int negativo = -2;\n    System.out.println(negativo >> 1);  // -1\n    System.out.println(negativo >>> 1); // 2147483647 (Entero positivo grande)\n}```"}
{"instruction": "Explica la clase PhantomReference.", "response": "El tipo de referencia más débil. Se usa para saber exactamente cuándo un objeto ha sido eliminado de memoria, interactuando con `ReferenceQueue`.\n\n```java\nimport java.lang.ref.*;\n\npublic class Fantasma {\n    public static void main(String[] args) {\n        Object obj = new Object();\n        ReferenceQueue<Object> q = new ReferenceQueue<>();\n        PhantomReference<Object> ph = new PhantomReference<>(obj, q);\n        obj = null;\n        System.gc();\n        // ph.get() siempre devuelve null\n    }\n}```"}
{"instruction": "Ordena una Pila (Stack) usando recursión (sin estructuras extra).", "response": "Saca el elemento, ordena el resto recursivamente e inserta el elemento en la posición correcta.\n\n```java\nimport java.util.Stack;\n\npublic void ordenarPila(Stack<Integer> s) {\n    if (s.isEmpty()) return;\n    int temp = s.pop();\n    ordenarPila(s);\n    insertarOrdenado(s, temp);\n}\n\nprivate void insertarOrdenado(Stack<Integer> s, int x) {\n    if (s.isEmpty() || x > s.peek()) s.push(x);\n    else {\n        int temp = s.pop();\n        insertarOrdenado(s, x);\n        s.push(temp);\n    }\n}```"}
{"instruction": "Implementa una Cola Circular usando un arreglo.", "response": "Uso eficiente de memoria fija. Los índices dan la vuelta al llegar al final del array usando módulo.\n\n```java\nclass ColaCircular {\n    int[] arr = new int[5];\n    int front = 0, rear = 0, size = 0;\n    \n    void encolar(int x) {\n        if (size == arr.length) return;\n        arr[rear] = x;\n        rear = (rear + 1) % arr.length;\n        size++;\n    }\n}```"}
{"instruction": "Calcula el Mínimo Común Múltiplo (LCM) usando GCD.", "response": "Fórmula matemática: LCM(a, b) = (a * b) / GCD(a, b).\n\n```java\npublic int lcm(int a, int b) {\n    if (a == 0 || b == 0) return 0;\n    return Math.abs(a * b) / gcd(a, b); \n    // Se asume método gcd implementado previamente\n}```"}
{"instruction": "Rellena una lista con copias de un mismo objeto con Collections.nCopies().", "response": "Crea una lista inmutable repetitiva eficiente en memoria.\n\n```java\nimport java.util.*;\n\npublic class Copias {\n    public static void main(String[] args) {\n        List<String> lista = Collections.nCopies(5, \"Dato\");\n        System.out.println(lista.size()); // 5\n    }\n}```"}
{"instruction": "Verifica si una colección y otra no tienen elementos en común (disjoint).", "response": "Retorna `true` si la intersección es vacía.\n\n```java\nimport java.util.Collections;\nimport java.util.Arrays;\n\npublic class Disjuntos {\n    public static void main(String[] args) {\n        boolean comun = Collections.disjoint(Arrays.asList(1, 2), Arrays.asList(3, 4));\n        System.out.println(comun); // true (no hay elementos comunes)\n    }\n}```"}
{"instruction": "Usa RandomAccessFile para leer en una posición específica de un archivo.", "response": "Permite mover el puntero de lectura (`seek`) a cualquier byte del archivo.\n\n```java\nimport java.io.RandomAccessFile;\n\npublic class LecturaAleatoria {\n    public static void leerByte(String path, int pos) throws Exception {\n        try (RandomAccessFile file = new RandomAccessFile(path, \"r\")) {\n            file.seek(pos);\n            System.out.println((char) file.read());\n        }\n    }\n}```"}
{"instruction": "Crea directorios recursivamente con Files.createDirectories().", "response": "Crea toda la ruta de carpetas si no existen (ej. `padre/hijo/nieto`).\n\n```java\nimport java.nio.file.*;\n\npublic class CrearRuta {\n    public static void main(String[] args) throws Exception {\n        Path path = Paths.get(\"data/logs/2023\");\n        Files.createDirectories(path);\n    }\n}```"}
{"instruction": "Copia un archivo reemplazando el existente con NIO.", "response": "Opciones de copia estándar (`REPLACE_EXISTING`).\n\n```java\nimport java.nio.file.*;\n\npublic class CopiarArchivo {\n    public static void copiar(Path origen, Path destino) throws Exception {\n        Files.copy(origen, destino, StandardCopyOption.REPLACE_EXISTING);\n    }\n}```"}
{"instruction": "Convierte un array de caracteres a String y viceversa.", "response": "Operaciones básicas de transformación de texto.\n\n```java\npublic void transformacion() {\n    char[] chars = {'J', 'a', 'v', 'a'};\n    String s = new String(chars);\n    char[] back = s.toCharArray();\n}```"}
{"instruction": "Verifica si un carácter es una letra o dígito.", "response": "`Character.isLetterOrDigit` es útil para validación de identificadores.\n\n```java\npublic boolean esAlfanumerico(char c) {\n    return Character.isLetterOrDigit(c);\n}```"}
{"instruction": "Explica la diferencia entre ceil(), floor() y round() en Math.", "response": "`ceil` sube al entero siguiente, `floor` baja, `round` redondea al más cercano.\n\n```java\npublic void redondeos() {\n    System.out.println(Math.ceil(2.1));  // 3.0\n    System.out.println(Math.floor(2.9)); // 2.0\n    System.out.println(Math.round(2.5)); // 3\n}```"}
{"instruction": "Usa ReentrantLock como alternativa flexible a synchronized.", "response": "Permite bloqueos con timeout, bloqueos justos (fairness) y desbloqueo en diferentes scopes.\n\n```java\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class Candado {\n    ReentrantLock lock = new ReentrantLock();\n    public void seguro() {\n        lock.lock();\n        try { /* Código crítico */ } \n        finally { lock.unlock(); }\n    }\n}```"}
{"instruction": "Detecta si un String es nulo o vacío (helper común).", "response": "Validación estándar antes de procesar cadenas.\n\n```java\npublic boolean isNullOrEmpty(String s) {\n    return s == null || s.trim().isEmpty();\n}```"}
{"instruction": "Usa StringBuilder deleteCharAt para manipular cadenas.", "response": "Útil para borrar el último separador en un bucle (ej. coma final).\n\n```java\npublic String generarLista(List<String> items) {\n    StringBuilder sb = new StringBuilder();\n    for(String s : items) sb.append(s).append(\",\");\n    if (sb.length() > 0) sb.deleteCharAt(sb.length() - 1); // Borra última coma\n    return sb.toString();\n}```"}
{"instruction": "Obtén variables de entorno del sistema con System.getenv().", "response": "Acceso a configuraciones del SO (PATH, USER, etc).\n\n```java\npublic void verVariable(String key) {\n    String valor = System.getenv(key);\n    System.out.println(key + \" = \" + valor);\n}```"}
{"instruction": "Lee propiedades del sistema Java con System.getProperty().", "response": "Información sobre la JVM, versión de Java, separador de archivos, etc.\n\n```java\npublic void infoSistema() {\n    System.out.println(System.getProperty(\"java.version\"));\n    System.out.println(System.getProperty(\"os.name\"));\n}```"}
{"instruction": "Usa java.time.format.DateTimeFormatter para parsear fechas.", "response": "Conversión segura de String a objetos de fecha modernos.\n\n```java\nimport java.time.LocalDate;\nimport java.time.format.DateTimeFormatter;\n\npublic class ParseoFecha {\n    public static void main(String[] args) {\n        DateTimeFormatter fmt = DateTimeFormatter.ofPattern(\"dd/MM/yyyy\");\n        LocalDate fecha = LocalDate.parse(\"25/12/2023\", fmt);\n        System.out.println(fecha.getMonth());\n    }\n}```"}
{"instruction": "Valida si un año es bisiesto con la API de tiempo.", "response": "`LocalDate` y `Year` tienen métodos integrados para esta lógica.\n\n```java\nimport java.time.Year;\n\npublic boolean esBisiesto(int anio) {\n    return Year.of(anio).isLeap();\n}```"}
{"instruction": "Usa Optional.map() para transformar valores si existen.", "response": "Si el Optional tiene valor, aplica la función; si está vacío, retorna vacío.\n\n```java\nimport java.util.Optional;\n\npublic void transformar(Optional<String> opt) {\n    Optional<Integer> largo = opt.map(String::length);\n    System.out.println(largo.orElse(0));\n}```"}
{"instruction": "Explica la interfaz Strategy con un ejemplo.", "response": "Permite definir una familia de algoritmos y hacerlos intercambiables en tiempo de ejecución.\n\n```java\ninterface Estrategia { int operar(int a, int b); }\n\nclass Suma implements Estrategia { \n    public int operar(int a, int b) { return a + b; }\n}\n\nclass Contexto {\n    Estrategia e;\n    Contexto(Estrategia e) { this.e = e; }\n    int ejecutar(int a, int b) { return e.operar(a, b); }\n}```"}
{"instruction": "Genera UUIDs únicos.", "response": "Identificadores universales únicos, útiles para claves primarias o tokens.\n\n```java\nimport java.util.UUID;\n\npublic class IDUnico {\n    public static void main(String[] args) {\n        System.out.println(UUID.randomUUID().toString());\n    }\n}```"}
{"instruction": "Realiza un recorrido DFS (Profundidad) iterativo usando una Pila explícita.", "response": "Evita el riesgo de StackOverflowError de la recursión en grafos muy profundos.\n\n```java\nimport java.util.*;\n\npublic void dfsIterativo(int inicio, Map<Integer, List<Integer>> adj) {\n    Stack<Integer> stack = new Stack<>();\n    Set<Integer> visitados = new HashSet<>();\n    stack.push(inicio);\n    \n    while (!stack.isEmpty()) {\n        int nodo = stack.pop();\n        if (!visitados.contains(nodo)) {\n            visitados.add(nodo);\n            System.out.print(nodo + \" \");\n            for (int vecino : adj.getOrDefault(nodo, new ArrayList<>())) {\n                stack.push(vecino);\n            }\n        }\n    }\n}```"}
{"instruction": "Usa la interfaz funcional Predicate para filtrar datos.", "response": "`Predicate<T>` toma un argumento y devuelve un booleano. Base de `filter` en Streams.\n\n```java\nimport java.util.function.Predicate;\n\npublic class Filtro {\n    public static void main(String[] args) {\n        Predicate<String> esLargo = s -> s.length() > 5;\n        System.out.println(esLargo.test(\"Hola\")); // false\n        System.out.println(esLargo.test(\"MundoJava\")); // true\n    }\n}```"}
{"instruction": "Usa la interfaz funcional Function para transformar datos.", "response": "`Function<T, R>` recibe un tipo T y retorna un tipo R.\n\n```java\nimport java.util.function.Function;\n\npublic class Transformador {\n    public static void main(String[] args) {\n        Function<String, Integer> longitud = String::length;\n        System.out.println(longitud.apply(\"Java\")); // 4\n    }\n}```"}
{"instruction": "Usa la interfaz funcional Supplier para generar valores (Lazy evaluation).", "response": "`Supplier<T>` no recibe argumentos y devuelve un resultado. Útil para generar datos bajo demanda.\n\n```java\nimport java.util.function.Supplier;\n\npublic class Generador {\n    public static void main(String[] args) {\n        Supplier<Double> random = Math::random;\n        System.out.println(random.get());\n    }\n}```"}
{"instruction": "Maneja zonas horarias con ZonedDateTime.", "response": "Representa fecha y hora con información completa de la zona horaria.\n\n```java\nimport java.time.*;\n\npublic class Zonas {\n    public static void main(String[] args) {\n        ZonedDateTime ahoraEnTokio = ZonedDateTime.now(ZoneId.of(\"Asia/Tokyo\"));\n        System.out.println(ahoraEnTokio);\n    }\n}```"}
{"instruction": "Calcula la diferencia en años, meses y días con Period.", "response": "`Period` se usa para fechas (`LocalDate`), mientras que `Duration` es para tiempo/horas.\n\n```java\nimport java.time.LocalDate;\nimport java.time.Period;\n\npublic class Edad {\n    public static void main(String[] args) {\n        LocalDate nacio = LocalDate.of(2000, 1, 1);\n        LocalDate ahora = LocalDate.now();\n        Period p = Period.between(nacio, ahora);\n        System.out.println(p.getYears() + \" años\");\n    }\n}```"}
{"instruction": "Implementa ReadWriteLock para optimizar lecturas concurrentes.", "response": "Permite múltiples lectores simultáneos, pero el escritor bloquea a todos. Ideal cuando hay muchas más lecturas que escrituras.\n\n```java\nimport java.util.concurrent.locks.*;\n\npublic class Cache {\n    private final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();\n    private final Lock r = rwl.readLock();\n    private final Lock w = rwl.writeLock();\n    \n    public void leer() {\n        r.lock();\n        try { /* Leer dato */ } finally { r.unlock(); }\n    }\n    public void escribir() {\n        w.lock();\n        try { /* Escribir dato */ } finally { w.unlock(); }\n    }\n}```"}
{"instruction": "Usa CopyOnWriteArrayList para listas thread-safe con muchas lecturas.", "response": "Crea una copia nueva del array interno en cada modificación. Muy costoso para escribir, muy rápido para leer.\n\n```java\nimport java.util.concurrent.CopyOnWriteArrayList;\n\npublic class ListaConcurrente {\n    public static void main(String[] args) {\n        CopyOnWriteArrayList<String> lista = new CopyOnWriteArrayList<>();\n        lista.add(\"A\");\n        // Seguro iterar mientras otro hilo modifica\n        for(String s : lista) System.out.println(s);\n    }\n}```"}
{"instruction": "Crea una clase completamente Inmutable.", "response": "Clase `final`, atributos `private final`, sin setters, y copia defensiva de objetos mutables en constructor/getters.\n\n```java\npublic final class Inmutable {\n    private final String nombre;\n    private final int[] datos;\n\n    public Inmutable(String nombre, int[] datos) {\n        this.nombre = nombre;\n        this.datos = datos.clone(); // Copia defensiva\n    }\n    public int[] getDatos() { return datos.clone(); }\n}```"}
{"instruction": "Usa métodos privados en interfaces (Java 9+).", "response": "Permite compartir código común entre métodos `default` de la interfaz sin exponerlo.\n\n```java\ninterface Calculadora {\n    default int sumar(int a, int b) { return validar(a) + validar(b); }\n    default int restar(int a, int b) { return validar(a) - validar(b); }\n    \n    // Método privado auxiliar\n    private int validar(int n) {\n        return n < 0 ? 0 : n;\n    }\n}```"}
{"instruction": "Mezcla dos listas enlazadas ordenadas en una sola lista ordenada.", "response": "Algoritmo clásico tipo 'cremallera' (Merge Two Sorted Lists).\n\n```java\npublic NodoSimple mergeListas(NodoSimple l1, NodoSimple l2) {\n    if (l1 == null) return l2;\n    if (l2 == null) return l1;\n    \n    if (l1.dato < l2.dato) {\n        l1.siguiente = mergeListas(l1.siguiente, l2);\n        return l1;\n    } else {\n        l2.siguiente = mergeListas(l1, l2.siguiente);\n        return l2;\n    }\n}```"}
{"instruction": "Implementa el Patrón Observer simple.", "response": "Un objeto (Sujeto) notifica a una lista de dependientes (Observadores) cuando cambia su estado.\n\n```java\nimport java.util.*;\n\nclass Sujeto {\n    List<Runnable> observadores = new ArrayList<>();\n    void agregar(Runnable obs) { observadores.add(obs); }\n    void notificar() { observadores.forEach(Runnable::run); }\n}\n// Uso: sujeto.agregar(() -> System.out.println(\"Evento recibido\"));```"}
{"instruction": "Implementa el Patrón Decorator (Ejemplo conceptual IO).", "response": "Añade funcionalidad dinámicamente envolviendo objetos. Ejemplo: BufferedInputStream envuelve a FileInputStream.\n\n```java\ninterface Cafe { double costo(); }\nclass Simple implements Cafe { public double costo() { return 1.0; } }\n\nclass ConLeche implements Cafe {\n    private Cafe c;\n    ConLeche(Cafe c) { this.c = c; }\n    public double costo() { return c.costo() + 0.5; }\n}```"}
{"instruction": "Evalúa una expresión en Notación Polaca Inversa (RPN) usando Pila.", "response": "Ejemplo: `3 4 +` -> `7`. Si es número, push; si es operador, pop dos números y operar.\n\n```java\nimport java.util.Stack;\n\npublic int evaluarRPN(String[] tokens) {\n    Stack<Integer> pila = new Stack<>();\n    for (String t : tokens) {\n        if (t.equals(\"+\")) pila.push(pila.pop() + pila.pop());\n        else if (t.equals(\"*\")) pila.push(pila.pop() * pila.pop());\n        else pila.push(Integer.parseInt(t));\n    }\n    return pila.pop();\n}```"}
{"instruction": "Usa 'yield' para retornar valores en un Switch Expression (Java 13+).", "response": "Reemplaza al `return` o `break` dentro de bloques de código en un switch moderno.\n\n```java\npublic int diasDelMes(String mes) {\n    return switch (mes) {\n        case \"Febrero\" -> {\n            System.out.println(\"Calculando bisiesto...\");\n            yield 28;\n        }\n        default -> 30;\n    };\n}```"}
{"instruction": "Realiza una petición HTTP GET simple (Java 11 HttpClient).", "response": "Cliente HTTP nativo, moderno y asíncrono, reemplazando a `HttpURLConnection`.\n\n```java\nimport java.net.http.*;\nimport java.net.URI;\n\npublic class HttpDemo {\n    public static void main(String[] args) throws Exception {\n        HttpClient client = HttpClient.newHttpClient();\n        HttpRequest req = HttpRequest.newBuilder(URI.create(\"[https://google.com](https://google.com)\")).build();\n        HttpResponse<String> res = client.send(req, HttpResponse.BodyHandlers.ofString());\n        System.out.println(res.statusCode());\n    }\n}```"}
{"instruction": "Codifica y decodifica texto en Base64.", "response": "Útil para transmitir datos binarios sobre protocolos de texto.\n\n```java\nimport java.util.Base64;\n\npublic class Base64Demo {\n    public static void main(String[] args) {\n        String original = \"Hola\";\n        String codificado = Base64.getEncoder().encodeToString(original.getBytes());\n        byte[] decodificado = Base64.getDecoder().decode(codificado);\n        System.out.println(new String(decodificado)); // Hola\n    }\n}```"}
{"instruction": "Genera el hash MD5 de un texto (Nota: MD5 no es seguro para crypto, solo integridad).", "response": "Uso de `MessageDigest` para hashing.\n\n```java\nimport java.security.MessageDigest;\n\npublic class HashMD5 {\n    public static void main(String[] args) throws Exception {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        byte[] hash = md.digest(\"password\".getBytes());\n        // Convertir bytes a Hexadecimal para mostrar\n    }\n}```"}
{"instruction": "Diferencia entre File.exists() (Legacy) y Files.exists() (NIO).", "response": "`Files.exists(Path)` es la forma moderna y maneja mejor enlaces simbólicos y permisos.\n\n```java\nimport java.nio.file.*;\n\npublic class VerificarArchivo {\n    public static void checar(String ruta) {\n        Path p = Paths.get(ruta);\n        System.out.println(Files.exists(p));\n    }\n}```"}
{"instruction": "Usa StandardCharsets para evitar errores de codificación.", "response": "Evita usar strings mágicos como `\"UTF-8\"` que pueden lanzar excepciones si están mal escritos.\n\n```java\nimport java.nio.charset.StandardCharsets;\n\npublic class Charsets {\n    public static void main(String[] args) {\n        byte[] bytes = \"Ñandú\".getBytes(StandardCharsets.UTF_8);\n        System.out.println(new String(bytes, StandardCharsets.UTF_8));\n    }\n}```"}
{"instruction": "Lee una contraseña de forma segura desde la consola.", "response": "`Console.readPassword` no muestra los caracteres mientras se escriben (echo off).\n\n```java\nimport java.io.Console;\n\npublic class Login {\n    public static void main(String[] args) {\n        Console consola = System.console();\n        if (consola != null) {\n            char[] pass = consola.readPassword(\"Password: \");\n            // Limpiar el array de caracteres en memoria después de usarlo\n        }\n    }\n}```"}
{"instruction": "Cede la ejecución del procesador con Thread.yield().", "response": "Sugerencia al planificador de hilos de que el hilo actual está dispuesto a pausarse para dejar pasar a otros de igual prioridad.\n\n```java\npublic void procesoAmable() {\n    for (int i = 0; i < 5; i++) {\n        Thread.yield(); // Cede turno\n        System.out.println(\"Procesando \" + i);\n    }\n}```"}
{"instruction": "Usa SoftReference para cachés sensibles a la memoria.", "response": "El GC solo limpia las `SoftReference` si la JVM se está quedando sin memoria (a diferencia de `WeakReference` que se limpia antes).\n\n```java\nimport java.lang.ref.SoftReference;\n\npublic class CacheSuave {\n    public static void main(String[] args) {\n        Object data = new byte[1024 * 1024];\n        SoftReference<Object> ref = new SoftReference<>(data);\n        data = null;\n        // El objeto sigue accesible a menos que falte RAM\n    }\n}```"}
{"instruction": "Rota una matriz 90 grados en el sentido de las agujas del reloj.", "response": "Manipulación de índices de matriz (Matriz[i][j] -> Matriz[j][n-1-i]).\n\n```java\npublic void rotar(int[][] matrix) {\n    int n = matrix.length;\n    // 1. Transponer\n    for(int i=0; i<n; i++)\n        for(int j=i; j<n; j++) {\n            int temp = matrix[i][j];\n            matrix[i][j] = matrix[j][i];\n            matrix[j][i] = temp;\n        }\n    // 2. Invertir filas (omitido por brevedad)\n}```"}
{"instruction": "Encuentra el número duplicado en un arreglo de n+1 enteros (Floyd Array).", "response": "Considera el array como una lista enlazada donde el valor es el índice del siguiente nodo.\n\n```java\npublic int encontrarDuplicado(int[] nums) {\n    int tortuga = nums[0];\n    int liebre = nums[0];\n    do {\n        tortuga = nums[tortuga];\n        liebre = nums[nums[liebre]];\n    } while (tortuga != liebre);\n    \n    tortuga = nums[0];\n    while (tortuga != liebre) {\n        tortuga = nums[tortuga];\n        liebre = nums[liebre];\n    }\n    return liebre;\n}```"}
{"instruction": "Encuentra el prefijo común más largo en un arreglo de cadenas.", "response": "Compara caracteres hasta que difieran.\n\n```java\npublic String prefijoComun(String[] strs) {\n    if (strs.length == 0) return \"\";\n    String prefix = strs[0];\n    for (int i = 1; i < strs.length; i++) {\n        while (strs[i].indexOf(prefix) != 0) {\n            prefix = prefix.substring(0, prefix.length() - 1);\n        }\n    }\n    return prefix;\n}```"}
{"instruction": "Determina si un entero es palíndromo sin convertirlo a String.", "response": "Invierte el número matemáticamente y compara con el original.\n\n```java\npublic boolean esPalindromoNum(int x) {\n    if (x < 0) return false;\n    int rev = 0, temp = x;\n    while (temp != 0) {\n        int digito = temp % 10;\n        rev = rev * 10 + digito;\n        temp /= 10;\n    }\n    return rev == x;\n}```"}
{"instruction": "Implementa la Criba de Eratóstenes para hallar primos hasta N.", "response": "Algoritmo eficiente para marcar no-primos en un arreglo booleano.\n\n```java\nimport java.util.Arrays;\n\npublic void criba(int n) {\n    boolean[] esPrimo = new boolean[n + 1];\n    Arrays.fill(esPrimo, true);\n    for (int p = 2; p * p <= n; p++) {\n        if (esPrimo[p]) {\n            for (int i = p * p; i <= n; i += p)\n                esPrimo[i] = false;\n        }\n    }\n}```"}
{"instruction": "Encuentra el primer carácter no repetido en un String.", "response": "Usa un mapa o array de frecuencias y luego recorre el string nuevamente.\n\n```java\npublic int primerUnico(String s) {\n    int[] freq = new int[26];\n    for (char c : s.toCharArray()) freq[c - 'a']++;\n    for (int i = 0; i < s.length(); i++) {\n        if (freq[s.charAt(i) - 'a'] == 1) return i;\n    }\n    return -1;\n}```"}
{"instruction": "Implementa una caché LRU (Least Recently Used) simple.", "response": "`LinkedHashMap` tiene un modo constructor especial para esto (accessOrder = true).\n\n```java\nimport java.util.LinkedHashMap;\nimport java.util.Map;\n\nclass LRUCache<K, V> extends LinkedHashMap<K, V> {\n    private int capacidad;\n    public LRUCache(int capacidad) {\n        super(capacidad, 0.75f, true);\n        this.capacidad = capacidad;\n    }\n    @Override\n    protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {\n        return size() > capacidad;\n    }\n}```"}
{"instruction": "Programa una tarea repetitiva con ScheduledExecutorService.", "response": "Alternativa robusta a `java.util.Timer`. Ejecuta código cada X tiempo.\n\n```java\nimport java.util.concurrent.*;\n\npublic class TareaProgramada {\n    public static void main(String[] args) {\n        ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);\n        scheduler.scheduleAtFixedRate(\n            () -> System.out.println(\"Bip\"), \n            0, 1, TimeUnit.SECONDS\n        );\n    }\n}```"}
{"instruction": "Sincroniza hilos en un punto común con CyclicBarrier.", "response": "Los hilos esperan en la barrera hasta que todos lleguen, luego la barrera se reinicia.\n\n```java\nimport java.util.concurrent.CyclicBarrier;\n\npublic class Barrera {\n    public static void main(String[] args) {\n        CyclicBarrier barrier = new CyclicBarrier(3, () -> System.out.println(\"Todos llegaron\"));\n        // Hilos llamarían a barrier.await()\n    }\n}```"}
{"instruction": "Intercambia datos entre dos hilos con Exchanger.", "response": "Punto de sincronización donde dos hilos intercambian objetos.\n\n```java\nimport java.util.concurrent.Exchanger;\n\npublic class IntercambioHilo {\n    public static void main(String[] args) {\n        Exchanger<String> ex = new Exchanger<>();\n        // Hilo 1: ex.exchange(\"Dato1\");\n        // Hilo 2: ex.exchange(\"Dato2\");\n    }\n}```"}
{"instruction": "Crea una lista de solo lectura con Collections.unmodifiableList().", "response": "Envuelve una lista existente. Cualquier intento de modificarla lanza excepción.\n\n```java\nimport java.util.*;\n\npublic class ReadOnly {\n    public static void main(String[] args) {\n        List<String> list = new ArrayList<>();\n        list.add(\"A\");\n        List<String> readOnly = Collections.unmodifiableList(list);\n        // readOnly.add(\"B\"); // Error\n    }\n}```"}
{"instruction": "Encuentra el índice del primer desajuste entre dos arrays con Arrays.mismatch().", "response": "Método de Java 9+ para comparar arrays eficientemente.\n\n```java\nimport java.util.Arrays;\n\npublic class Desajuste {\n    public static void main(String[] args) {\n        int[] a = {1, 2, 3};\n        int[] b = {1, 2, 4};\n        System.out.println(Arrays.mismatch(a, b)); // 2 (índice donde difieren)\n    }\n}```"}
{"instruction": "Utiliza StringTokenizer para dividir cadenas (Método Legacy).", "response": "Aunque `split` es más común, `StringTokenizer` es más rápido para separaciones simples sin Regex.\n\n```java\nimport java.util.StringTokenizer;\n\npublic class TokenizerDemo {\n    public static void main(String[] args) {\n        StringTokenizer st = new StringTokenizer(\"Java,Python,Go\", \",\");\n        while (st.hasMoreTokens()) {\n            System.out.println(st.nextToken());\n        }\n    }\n}```"}
{"instruction": "Crea un adaptador (Adapter Pattern) para hacer compatibles dos interfaces.", "response": "Envuelve una clase existente para que coincida con la interfaz esperada.\n\n```java\ninterface EnchufeRedondo { void conectar(); }\nclass EnchufeCuadrado { void enchufar() {} }\n\nclass Adaptador implements EnchufeRedondo {\n    EnchufeCuadrado cuadrado;\n    Adaptador(EnchufeCuadrado c) { this.cuadrado = c; }\n    public void conectar() { cuadrado.enchufar(); }\n}```"}
{"instruction": "Calcula el límite inferior (Lower Bound) en búsqueda binaria.", "response": "Encuentra la primera aparición de un valor o donde debería insertarse.\n\n```java\npublic int lowerBound(int[] arr, int target) {\n    int l = 0, r = arr.length;\n    while (l < r) {\n        int mid = l + (r - l) / 2;\n        if (arr[mid] >= target) r = mid;\n        else l = mid + 1;\n    }\n    return l;\n}```"}
{"instruction": "Usa Comparator.comparing() para comparadores encadenados.", "response": "Ordena por un campo, y si son iguales, por otro.\n\n```java\nimport java.util.*;\n\nclass Persona { String nombre; int edad; }\n\npublic class OrdenCadena {\n    public void ordenar(List<Persona> p) {\n        p.sort(Comparator.comparing((Persona per) -> per.nombre)\n                         .thenComparingInt(per -> per.edad));\n    }\n}```"}
{"instruction": "Recorre una matriz en espiral.", "response": "Algoritmo de simulación que cambia límites (arriba, abajo, izquierda, derecha) progresivamente.\n\n```java\npublic void espiral(int[][] matriz) {\n    int top = 0, bottom = matriz.length-1, left = 0, right = matriz[0].length-1;\n    while(top <= bottom && left <= right) {\n        for(int i=left; i<=right; i++) System.out.print(matriz[top][i] + \" \");\n        top++;\n        // Resto de la lógica para bajar, izquierda y subir...\n    }\n}```"}
{"instruction": "Define una jerarquía de clases restringida usando Sealed Classes (Java 17).", "response": "Permite controlar qué clases pueden extender a una clase padre, mejorando el modelado de dominio.\n\n```java\npublic sealed class Forma permits Circulo, Rectangulo {}\n\nfinal class Circulo extends Forma {}\nfinal class Rectangulo extends Forma {}\n// class Triangulo extends Forma {} // Error de compilación: no permitido\n```"}
{"instruction": "Obtén estadísticas (min, max, promedio) de un array numérico con IntStream.", "response": "`summaryStatistics()` calcula múltiples métricas en una sola pasada sobre los datos.\n\n```java\nimport java.util.IntSummaryStatistics;\nimport java.util.stream.IntStream;\n\npublic class Stats {\n    public static void main(String[] args) {\n        int[] datos = {1, 5, 10, 20};\n        IntSummaryStatistics stats = IntStream.of(datos).summaryStatistics();\n        System.out.println(\"Promedio: \" + stats.getAverage());\n        System.out.println(\"Máximo: \" + stats.getMax());\n    }\n}```"}
{"instruction": "Crea un archivo temporal en el sistema con Files.createTempFile().", "response": "Útil para almacenar datos transitorios que no necesitan persistir tras reiniciar.\n\n```java\nimport java.nio.file.*;\n\npublic class TempFile {\n    public static void main(String[] args) throws Exception {\n        // Crea un archivo con prefijo \"miApp\" y extensión \".tmp\"\n        Path temp = Files.createTempFile(\"miApp\", \".tmp\");\n        System.out.println(\"Archivo creado en: \" + temp);\n    }\n}```"}
{"instruction": "Divide un String multilínea en un Stream de líneas con lines() (Java 11).", "response": "Método eficiente para procesar texto línea por línea sin usar `split` o `BufferedReader`.\n\n```java\npublic void procesarTexto(String texto) {\n    texto.lines()\n         .filter(linea -> !linea.isBlank())\n         .forEach(System.out::println);\n}```"}
{"instruction": "Repite una cadena N veces con String.repeat() (Java 11).", "response": "Simplifica la generación de patrones de texto o indentación.\n\n```java\npublic class Repetir {\n    public static void main(String[] args) {\n        String separador = \"-=\".repeat(5);\n        System.out.println(separador); // -=-=-=-=-=\n    }\n}```"}
{"instruction": "Reemplaza todos los elementos de una lista que cumplan una condición.", "response": "`Collections.replaceAll` o `List.replaceAll` (Java 8) modifica la lista in-place.\n\n```java\nimport java.util.*;\n\npublic class Reemplazo {\n    public static void main(String[] args) {\n        List<Integer> nums = new ArrayList<>(Arrays.asList(1, 2, 3));\n        // Reemplaza cada elemento por su cuadrado usando UnaryOperator\n        nums.replaceAll(n -> n * n);\n        System.out.println(nums); // [1, 4, 9]\n    }\n}```"}
{"instruction": "Implementa la estructura de datos Union-Find (Disjoint Set) - Método Find.", "response": "Esencial para algoritmos como Kruskal. Encuentra el representante del conjunto.\n\n```java\nclass UnionFind {\n    int[] padre;\n    public UnionFind(int n) {\n        padre = new int[n];\n        for(int i=0; i<n; i++) padre[i] = i;\n    }\n    public int find(int i) {\n        if (padre[i] == i) return i;\n        return padre[i] = find(padre[i]); // Path compression\n    }\n}```"}
{"instruction": "Implementa la operación Union en la estructura Union-Find.", "response": "Une dos subconjuntos en uno solo.\n\n```java\npublic void union(int i, int j) {\n    int raizI = find(i);\n    int raizJ = find(j);\n    if (raizI != raizJ) {\n        padre[raizI] = raizJ;\n    }\n}```"}
{"instruction": "Define la estructura de un nodo para un Trie (Árbol de Prefijos).", "response": "Estructura eficiente para autocompletado y búsqueda de palabras.\n\n```java\nclass TrieNode {\n    TrieNode[] hijos = new TrieNode[26];\n    boolean esFinDePalabra;\n    \n    public TrieNode() {\n        esFinDePalabra = false;\n        for (int i = 0; i < 26; i++) hijos[i] = null;\n    }\n}```"}
{"instruction": "Implementa la inserción en un Trie.", "response": "Recorre carácter por carácter creando nodos si no existen.\n\n```java\npublic void insertar(TrieNode raiz, String palabra) {\n    TrieNode actual = raiz;\n    for (char c : palabra.toCharArray()) {\n        int index = c - 'a';\n        if (actual.hijos[index] == null) actual.hijos[index] = new TrieNode();\n        actual = actual.hijos[index];\n    }\n    actual.esFinDePalabra = true;\n}```"}
{"instruction": "Interrumpe un hilo y maneja la interrupción correctamente.", "response": "Cuando un hilo es interrumpido, debe limpiar y salir o relanzar la señal.\n\n```java\npublic void tarea() {\n    Thread t = new Thread(() -> {\n        while (!Thread.currentThread().isInterrupted()) {\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt(); // Restaura estado\n                System.out.println(\"Interrumpido\");\n            }\n        }\n    });\n    t.start();\n    t.interrupt();\n}```"}
{"instruction": "Define una Anotación (Annotation) personalizada en Java.", "response": "Las anotaciones agregan metadatos al código, accesibles vía reflexión.\n\n```java\nimport java.lang.annotation.*;\n\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.METHOD)\npublic @interface Ejecutar {\n    int veces() default 1;\n}```"}
{"instruction": "Procesa una anotación personalizada usando Reflexión.", "response": "Lee la configuración de la anotación y ejecuta lógica basada en ella.\n\n```java\nimport java.lang.reflect.Method;\n\npublic class Procesador {\n    public static void main(String[] args) throws Exception {\n        Method m = MiClase.class.getMethod(\"miMetodo\");\n        if (m.isAnnotationPresent(Ejecutar.class)) {\n            Ejecutar an = m.getAnnotation(Ejecutar.class);\n            System.out.println(\"Ejecutar \" + an.veces() + \" veces.\");\n        }\n    }\n}```"}
{"instruction": "Comprime un archivo en formato ZIP usando ZipOutputStream.", "response": "Java IO estándar permite comprimir flujos de datos.\n\n```java\nimport java.util.zip.*;\nimport java.io.*;\n\npublic class ZipDemo {\n    public static void comprimir(String archivo, String zipSalida) throws IOException {\n        try (ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(zipSalida))) {\n            zos.putNextEntry(new ZipEntry(archivo));\n            // Aquí se escribirían los bytes del archivo original\n            zos.closeEntry();\n        }\n    }\n}```"}
{"instruction": "Usa la interfaz funcional UnaryOperator.", "response": "Especialización de `Function` donde la entrada y salida son del mismo tipo.\n\n```java\nimport java.util.function.UnaryOperator;\n\npublic class Unario {\n    public static void main(String[] args) {\n        UnaryOperator<Integer> cuadrado = x -> x * x;\n        System.out.println(cuadrado.apply(5)); // 25\n    }\n}```"}
{"instruction": "Usa la interfaz funcional BinaryOperator.", "response": "Especialización de `BiFunction` para dos operandos del mismo tipo que retornan ese tipo.\n\n```java\nimport java.util.function.BinaryOperator;\n\npublic class Binario {\n    public static void main(String[] args) {\n        BinaryOperator<Integer> multiplicar = (a, b) -> a * b;\n        System.out.println(multiplicar.apply(3, 4)); // 12\n    }\n}```"}
{"instruction": "Usa la interfaz funcional BiFunction para combinar tipos distintos.", "response": "Toma dos argumentos de tipos T y U, y retorna un resultado R.\n\n```java\nimport java.util.function.BiFunction;\n\npublic class BiFunc {\n    public static void main(String[] args) {\n        // Combina String e Integer para retornar String\n        BiFunction<String, Integer, String> repetir = (s, n) -> s.repeat(n);\n        System.out.println(repetir.apply(\"Go\", 3)); // GoGoGo\n    }\n}```"}
{"instruction": "Sincroniza fases de tareas concurrentes con Phaser.", "response": "Más flexible que `CountDownLatch` o `CyclicBarrier`, permite registrar/desregistrar hilos dinámicamente.\n\n```java\nimport java.util.concurrent.Phaser;\n\npublic class Fases {\n    public static void main(String[] args) {\n        Phaser phaser = new Phaser(1); // Registrar hilo actual\n        phaser.arriveAndAwaitAdvance(); // Esperar fase 1\n        System.out.println(\"Fase 1 completada\");\n        phaser.arriveAndDeregister();\n    }\n}```"}
{"instruction": "Usa StampedLock para lecturas optimistas (Optimistic Locking).", "response": "Permite leer sin bloquear si no hay escrituras, validando después si hubo cambios. Más rápido que `ReentrantReadWriteLock`.\n\n```java\nimport java.util.concurrent.locks.StampedLock;\n\npublic class Punto {\n    private double x, y;\n    private final StampedLock sl = new StampedLock();\n\n    public double distanciaOrigen() {\n        long stamp = sl.tryOptimisticRead();\n        double currentX = x, currentY = y;\n        if (!sl.validate(stamp)) {\n            stamp = sl.readLock();\n            try { currentX = x; currentY = y; } finally { sl.unlockRead(stamp); }\n        }\n        return Math.sqrt(currentX * currentX + currentY * currentY);\n    }\n}```"}
{"instruction": "Valida paréntesis balanceados incluyendo corchetes y llaves { [ ( ).", "response": "Extensión del problema de pila clásico para soportar múltiples tipos de apertura.\n\n```java\nimport java.util.Stack;\n\npublic boolean balanceadoCompleto(String s) {\n    Stack<Character> stack = new Stack<>();\n    for (char c : s.toCharArray()) {\n        if (c == '(') stack.push(')');\n        else if (c == '{') stack.push('}');\n        else if (c == '[') stack.push(']');\n        else if (stack.isEmpty() || stack.pop() != c) return false;\n    }\n    return stack.isEmpty();\n}```"}
{"instruction": "Suma dos matrices bidimensionales.", "response": "Iteración simple sumando celda a celda.\n\n```java\npublic int[][] sumarMatrices(int[][] A, int[][] B) {\n    int n = A.length;\n    int[][] C = new int[n][n];\n    for(int i=0; i<n; i++)\n        for(int j=0; j<n; j++)\n            C[i][j] = A[i][j] + B[i][j];\n    return C;\n}```"}
{"instruction": "Verifica si una matriz es simétrica (A[i][j] == A[j][i]).", "response": "Una matriz es simétrica si es igual a su transpuesta.\n\n```java\npublic boolean esSimetrica(int[][] mat) {\n    for (int i = 0; i < mat.length; i++) {\n        for (int j = i + 1; j < mat.length; j++) {\n            if (mat[i][j] != mat[j][i]) return false;\n        }\n    }\n    return true;\n}```"}
{"instruction": "Convierte un arreglo a una lista inmutable.", "response": "Desde Java 9+ es muy directo.\n\n```java\nimport java.util.List;\npublic class ArrayToList {\n    public static void main(String[] args) {\n        String[] arr = {\"A\", \"B\"};\n        List<String> lista = List.of(arr);\n        // lista.add(\"C\"); // Error\n    }\n}```"}
{"instruction": "Inicializa un arreglo utilizando una función generadora con Arrays.setAll().", "response": "Llena el arreglo basándose en el índice.\n\n```java\nimport java.util.Arrays;\n\npublic class SetAllDemo {\n    public static void main(String[] args) {\n        int[] pares = new int[5];\n        Arrays.setAll(pares, i -> i * 2);\n        System.out.println(Arrays.toString(pares)); // [0, 2, 4, 6, 8]\n    }\n}```"}
{"instruction": "Verifica si un número BigInteger es probablemente primo.", "response": "Usa el test de Miller-Rabin internamente.\n\n```java\nimport java.math.BigInteger;\n\npublic class PrimoGrande {\n    public static void main(String[] args) {\n        BigInteger n = new BigInteger(\"13\");\n        System.out.println(n.isProbablePrime(10)); // true (certeza alta)\n    }\n}```"}
{"instruction": "Cuenta los bits encendidos en un BitSet (Cardinalidad).", "response": "`cardinality()` devuelve el número de bits puestos a true.\n\n```java\nimport java.util.BitSet;\n\npublic class ConteoBits {\n    public static void main(String[] args) {\n        BitSet bs = new BitSet();\n        bs.set(10); bs.set(20);\n        System.out.println(bs.cardinality()); // 2\n    }\n}```"}
{"instruction": "Usa LongAdder para contadores de alto rendimiento en concurrencia.", "response": "Mejor que `AtomicLong` cuando hay mucha contención de hilos escribiendo.\n\n```java\nimport java.util.concurrent.atomic.LongAdder;\n\npublic class SumadorRapido {\n    public static void main(String[] args) {\n        LongAdder adder = new LongAdder();\n        adder.increment();\n        adder.add(10);\n        System.out.println(adder.sum()); // 11\n    }\n}```"}
{"instruction": "Crea un cliente Socket básico (TCP).", "response": "Conecta a un servidor y envía un mensaje simple.\n\n```java\nimport java.net.Socket;\nimport java.io.OutputStream;\n\npublic class ClienteTCP {\n    public static void conectar() throws Exception {\n        try (Socket socket = new Socket(\"localhost\", 8080)) {\n            OutputStream out = socket.getOutputStream();\n            out.write(\"Hola Servidor\".getBytes());\n        }\n    }\n}```"}
{"instruction": "Crea un servidor ServerSocket básico.", "response": "Espera conexiones entrantes en un puerto.\n\n```java\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class ServidorTCP {\n    public static void iniciar() throws Exception {\n        ServerSocket server = new ServerSocket(8080);\n        System.out.println(\"Esperando...\");\n        Socket cliente = server.accept(); // Bloquea hasta que alguien conecta\n        System.out.println(\"Conectado: \" + cliente.getInetAddress());\n    }\n}```"}
{"instruction": "Lee contenido desde una URL.", "response": "Acceso básico a recursos web usando la clase URL.\n\n```java\nimport java.net.URL;\nimport java.util.Scanner;\n\npublic class LeerWeb {\n    public static void main(String[] args) throws Exception {\n        URL url = new URL(\"[http://example.com](http://example.com)\");\n        Scanner sc = new Scanner(url.openStream());\n        // Lee el HTML (o parte de él)\n        if(sc.hasNext()) System.out.println(sc.nextLine());\n    }\n}```"}
{"instruction": "Verifica si una cadena contiene solo dígitos manualmente.", "response": "Alternativa sin regex para validar numéricos.\n\n```java\npublic boolean soloDigitos(String s) {\n    for (char c : s.toCharArray()) {\n        if (!Character.isDigit(c)) return false;\n    }\n    return true;\n}```"}
{"instruction": "Elimina todos los espacios en blanco de una cadena.", "response": "Usa regex `\\s` que cubre espacios, tabs y saltos de línea.\n\n```java\npublic String limpiarEspacios(String s) {\n    return s.replaceAll(\"\\\\s+\", \"\");\n}```"}
{"instruction": "Valida un email simple con Expresiones Regulares.", "response": "Validación básica de formato de correo.\n\n```java\npublic boolean esEmail(String email) {\n    return email.matches(\"^[\\\\w-\\\\.]+@([\\\\w-]+\\\\.)+[\\\\w-]{2,4}$\");\n}```"}
{"instruction": "Carga configuraciones desde un archivo .properties.", "response": "Estándar en Java para manejar configuraciones clave-valor.\n\n```java\nimport java.util.Properties;\nimport java.io.FileReader;\n\npublic class Config {\n    public static void cargar() throws Exception {\n        Properties p = new Properties();\n        p.load(new FileReader(\"config.properties\"));\n        System.out.println(p.getProperty(\"db.user\"));\n    }\n}```"}
{"instruction": "Usa ResourceBundle para Internacionalización (i18n).", "response": "Carga archivos de propiedades según el Locale del usuario.\n\n```java\nimport java.util.ResourceBundle;\nimport java.util.Locale;\n\npublic class Idioma {\n    public static void main(String[] args) {\n        // Busca mensajes_es.properties o mensajes_en.properties\n        ResourceBundle rb = ResourceBundle.getBundle(\"mensajes\", Locale.US);\n        System.out.println(rb.getString(\"saludo\"));\n    }\n}```"}
{"instruction": "Genera una secuencia infinita con Stream.iterate().", "response": "Crea un stream sin fin aplicando una función semilla (ej. números pares).\n\n```java\nimport java.util.stream.Stream;\n\npublic class Infinito {\n    public static void main(String[] args) {\n        Stream.iterate(0, n -> n + 2)\n              .limit(5) // Importante limitar para no colgar\n              .forEach(System.out::println);\n    }\n}```"}
{"instruction": "Genera datos constantes o aleatorios con Stream.generate().", "response": "Similar a iterate pero sin dependencia del valor anterior.\n\n```java\nimport java.util.stream.Stream;\n\npublic class GenerarStream {\n    public static void main(String[] args) {\n        Stream.generate(() -> \"Eco\")\n              .limit(3)\n              .forEach(System.out::print); // EcoEcoEco\n    }\n}```"}
{"instruction": "Usa Optional.filter() para aplicar condiciones al valor opcional.", "response": "Si el valor existe y cumple la condición, se mantiene; si no, el Optional se vacía.\n\n```java\nimport java.util.Optional;\n\npublic class FiltrarOp {\n    public static void main(String[] args) {\n        Optional<String> opt = Optional.of(\"Java\");\n        opt.filter(s -> s.length() > 10)\n           .ifPresent(System.out::println); // No imprime nada\n    }\n}```"}
{"instruction": "Usa Optional.ifPresentOrElse() (Java 9) para manejar ambos casos.", "response": "Ejecuta una acción si existe el valor, y otra acción (Runnable) si no.\n\n```java\nimport java.util.Optional;\n\npublic class OpJava9 {\n    public static void main(String[] args) {\n        Optional<String> opt = Optional.empty();\n        opt.ifPresentOrElse(\n            System.out::println,\n            () -> System.out.println(\"Vacío\")\n        );\n    }\n}```"}
{"instruction": "Obtén la memoria libre disponible para la JVM.", "response": "Información del sistema en tiempo de ejecución.\n\n```java\npublic class MemoriaInfo {\n    public static void main(String[] args) {\n        long libre = Runtime.getRuntime().freeMemory();\n        System.out.println(\"Bytes libres: \" + libre);\n    }\n}```"}
{"instruction": "Obtén el Hash Code de identidad de un objeto.", "response": "Retorna el hash original del objeto, ignorando si la clase sobrescribió `hashCode()`.\n\n```java\npublic class IdentidadHash {\n    public static void main(String[] args) {\n        String s = \"Hola\";\n        // Puede ser distinto a s.hashCode()\n        System.out.println(System.identityHashCode(s));\n    }\n}```"}
{"instruction": "Genera el hash de múltiples campos con Objects.hash().", "response": "Método estándar para implementar `hashCode()` en POJOs.\n\n```java\nimport java.util.Objects;\n\nclass Punto {\n    int x, y;\n    @Override\n    public int hashCode() {\n        return Objects.hash(x, y);\n    }\n}```"}
{"instruction": "Usa Comparator.nullsFirst para ordenar listas con nulos.", "response": "Evita `NullPointerException` al ordenar colecciones que contienen null.\n\n```java\nimport java.util.*;\n\npublic class OrdenNulos {\n    public static void main(String[] args) {\n        List<String> l = Arrays.asList(\"B\", null, \"A\");\n        l.sort(Comparator.nullsFirst(String::compareTo));\n        System.out.println(l); // [null, A, B]\n    }\n}```"}
{"instruction": "Invierte el orden de una lista con Collections.reverse().", "response": "Modifica la lista original invirtiendo sus elementos.\n\n```java\nimport java.util.*;\n\npublic class InvertirLista {\n    public static void main(String[] args) {\n        List<Integer> l = Arrays.asList(1, 2, 3);\n        Collections.reverse(l);\n        System.out.println(l); // [3, 2, 1]\n    }\n}```"}
{"instruction": "Rota los elementos de una lista con Collections.rotate().", "response": "Mueve los elementos N pasos a la derecha, dando la vuelta.\n\n```java\nimport java.util.*;\n\npublic class RotarLista {\n    public static void main(String[] args) {\n        List<Integer> l = Arrays.asList(1, 2, 3, 4, 5);\n        Collections.rotate(l, 2);\n        System.out.println(l); // [4, 5, 1, 2, 3]\n    }\n}```"}
{"instruction": "Obtén el estado actual de un hilo (NEW, RUNNABLE, BLOCKED, etc).", "response": "Útil para diagnósticos y monitoreo.\n\n```java\npublic class EstadoHilo {\n    public static void main(String[] args) {\n        Thread t = new Thread(() -> {});\n        System.out.println(t.getState()); // NEW\n        t.start();\n    }\n}```"}
{"instruction": "Cambia la prioridad de un hilo.", "response": "Sugerencia al planificador del SO sobre la importancia del hilo (1 a 10).\n\n```java\npublic class Prioridad {\n    public static void main(String[] args) {\n        Thread t = new Thread(() -> {});\n        t.setPriority(Thread.MAX_PRIORITY); // 10\n        t.start();\n    }\n}```"}
{"instruction": "Usa LinkedBlockingQueue para un productor-consumidor eficiente.", "response": "Cola bloqueante basada en nodos enlazados, opcionalmente acotada.\n\n```java\nimport java.util.concurrent.LinkedBlockingQueue;\n\npublic class LBQ {\n    public static void main(String[] args) throws InterruptedException {\n        LinkedBlockingQueue<String> q = new LinkedBlockingQueue<>(5);\n        q.put(\"Dato\");\n        System.out.println(q.take());\n    }\n}```"}
{"instruction": "Fusiona valores en un Mapa con Map.merge().", "response": "Método eficiente para actualizar valores o agregar nuevos si no existen, usando una función de remapeo.\n\n```java\nimport java.util.*;\n\npublic class MapMerge {\n    public static void main(String[] args) {\n        Map<String, Integer> inventario = new HashMap<>();\n        inventario.put(\"A\", 1);\n        // Si \"A\" existe, suma 1 al valor actual. Si no, inserta 1.\n        inventario.merge(\"A\", 1, Integer::sum);\n        System.out.println(inventario.get(\"A\")); // 2\n    }\n}```"}
{"instruction": "Elimina duplicados de un Stream con distinct().", "response": "Filtra el stream manteniendo solo elementos únicos (basado en `equals`).\n\n```java\nimport java.util.stream.Stream;\n\npublic class Distintos {\n    public static void main(String[] args) {\n        Stream.of(1, 2, 2, 3, 1)\n              .distinct()\n              .forEach(System.out::print); // 123\n    }\n}```"}
{"instruction": "Particiona una lista en dos grupos con Collectors.partitioningBy().", "response": "Divide los elementos en un Map con claves `true` y `false` según un predicado.\n\n```java\nimport java.util.*;\nimport java.util.stream.Collectors;\n\npublic class Particionar {\n    public static void main(String[] args) {\n        List<Integer> nums = Arrays.asList(1, 2, 3, 4);\n        Map<Boolean, List<Integer>> pares = nums.stream()\n            .collect(Collectors.partitioningBy(n -> n % 2 == 0));\n        System.out.println(\"Pares: \" + pares.get(true));\n    }\n}```"}
{"instruction": "Usa flatMapToInt para aplanar streams de primitivos.", "response": "Optimiza memoria evitando el boxing de `Integer` cuando se trabaja con arrays de `int`.\n\n```java\nimport java.util.stream.IntStream;\nimport java.util.Arrays;\n\npublic class FlatInt {\n    public static void main(String[] args) {\n        int[][] matriz = {{1, 2}, {3, 4}};\n        IntStream stream = Arrays.stream(matriz).flatMapToInt(Arrays::stream);\n        System.out.println(stream.sum()); // 10\n    }\n}```"}
{"instruction": "Retorna una lista vacía inmutable con Collections.emptyList() para evitar null.", "response": "Buena práctica: retornar una colección vacía en lugar de `null` para evitar `NullPointerException` en el cliente.\n\n```java\nimport java.util.*;\n\npublic List<String> obtenerNombres() {\n    // Lógica que no encontró resultados\n    return Collections.emptyList();\n}```"}
{"instruction": "Crea un conjunto con un solo elemento usando Collections.singleton().", "response": "Crea un Set inmutable de tamaño 1, más eficiente que crear un HashSet completo.\n\n```java\nimport java.util.*;\n\npublic class SingletonSet {\n    public static void main(String[] args) {\n        Set<String> set = Collections.singleton(\"Único\");\n        // set.add(\"Otro\"); // Error: UnsupportedOperationException\n    }\n}```"}
{"instruction": "Compara arrays lexicográficamente con Arrays.compare() (Java 9).", "response": "Retorna negativo, cero o positivo, similar a `compareTo` de Strings.\n\n```java\nimport java.util.Arrays;\n\npublic class CompararArrays {\n    public static void main(String[] args) {\n        int[] a = {1, 2, 3};\n        int[] b = {1, 2, 4};\n        System.out.println(Arrays.compare(a, b)); // -1 (a es menor que b)\n    }\n}```"}
{"instruction": "Verifica si el contenido de un String es igual a un StringBuilder con contentEquals().", "response": "Evita convertir el StringBuilder a String solo para comparar.\n\n```java\npublic boolean compararEficiente(String s, StringBuilder sb) {\n    return s.contentEquals(sb);\n}```"}
{"instruction": "Diferencia entre strip() (Java 11) y trim().", "response": "`strip()` es compatible con Unicode y elimina más tipos de espacios en blanco que el antiguo `trim()`.\n\n```java\npublic void limpiarTexto() {\n    String s = \"\\u2000 Hola \\u2000\";\n    System.out.println(s.trim().length());  // No elimina espacio Unicode\n    System.out.println(s.strip().length()); // 4 (Elimina correctamente)\n}```"}
{"instruction": "Detecta espacios en blanco Unicode con Character.isWhitespace().", "response": "Método robusto para validar separadores en internacionalización.\n\n```java\npublic boolean tieneEspacio(char c) {\n    return Character.isWhitespace(c);\n}```"}
{"instruction": "Convierte un entero a su representación Hexadecimal.", "response": "Útil para depuración, colores o criptografía.\n\n```java\npublic String aHex(int n) {\n    return Integer.toHexString(n).toUpperCase();\n}```"}
{"instruction": "Calcula la hipotenusa con Math.hypot().", "response": "Calcula `sqrt(x^2 + y^2)` previniendo desbordamientos intermedios.\n\n```java\npublic double calcularHipotenusa(double cateto1, double cateto2) {\n    return Math.hypot(cateto1, cateto2);\n}```"}
{"instruction": "Calcula el logaritmo natural y base 10.", "response": "Funciones matemáticas estándar en la clase Math.\n\n```java\npublic void logs(double valor) {\n    System.out.println(\"Ln: \" + Math.log(valor));\n    System.out.println(\"Log10: \" + Math.log10(valor));\n}```"}
{"instruction": "Genera números aleatorios criptográficamente seguros con SecureRandom.", "response": "Necesario para generar contraseñas, tokens o claves, donde `Random` es predecible.\n\n```java\nimport java.security.SecureRandom;\n\npublic class Segura {\n    public static void main(String[] args) {\n        SecureRandom sr = new SecureRandom();\n        int token = sr.nextInt();\n        System.out.println(token);\n    }\n}```"}
{"instruction": "Usa AtomicBoolean para flags de estado thread-safe.", "response": "Permite cambiar un booleano atómicamente sin usar `synchronized`.\n\n```java\nimport java.util.concurrent.atomic.AtomicBoolean;\n\npublic class FlagAtomico {\n    private AtomicBoolean activo = new AtomicBoolean(false);\n    \n    public void activarSoloUnaVez() {\n        if (activo.compareAndSet(false, true)) {\n            System.out.println(\"Activado por primera vez\");\n        }\n    }\n}```"}
{"instruction": "Actualiza una referencia de objeto atómicamente con AtomicReference.", "response": "Útil para implementar estructuras de datos concurrentes sin bloqueo (lock-free).\n\n```java\nimport java.util.concurrent.atomic.AtomicReference;\n\npublic class RefAtomica {\n    public static void main(String[] args) {\n        AtomicReference<String> ref = new AtomicReference<>(\"Inicial\");\n        ref.set(\"Nuevo\");\n        System.out.println(ref.get());\n    }\n}```"}
{"instruction": "Intenta adquirir un bloqueo sin esperar indefinidamente con tryLock().", "response": "Evita que un hilo se quede colgado si el recurso está ocupado.\n\n```java\nimport java.util.concurrent.locks.*;\n\npublic class IntentoBloqueo {\n    Lock lock = new ReentrantLock();\n    public void operacionRapida() {\n        if (lock.tryLock()) {\n            try { System.out.println(\"Bloqueo adquirido\"); }\n            finally { lock.unlock(); }\n        } else {\n            System.out.println(\"Ocupado, hago otra cosa...\");\n        }\n    }\n}```"}
{"instruction": "Simula un Deadlock (Bloqueo Mutuo) simple.", "response": "Ocurre cuando dos hilos esperan recursos que el otro tiene. Ejemplo educativo.\n\n```java\npublic class DeadlockDemo {\n    static final Object R1 = new Object();\n    static final Object R2 = new Object();\n    \n    public static void main(String[] args) {\n        new Thread(() -> { synchronized(R1) { \n            try{Thread.sleep(100);}catch(Exception e){}\n            synchronized(R2) {} \n        }}).start();\n        \n        new Thread(() -> { synchronized(R2) { \n            synchronized(R1) {} \n        }}).start();\n    }\n}```"}
{"instruction": "Espera a que múltiples CompletableFuture terminen con allOf().", "response": "Retorna un nuevo futuro que se completa cuando todos los dados se completan.\n\n```java\nimport java.util.concurrent.CompletableFuture;\n\npublic class TodosFuturos {\n    public static void main(String[] args) {\n        CompletableFuture<Void> todos = CompletableFuture.allOf(\n            CompletableFuture.runAsync(() -> System.out.println(\"A\")),\n            CompletableFuture.runAsync(() -> System.out.println(\"B\"))\n        );\n        todos.join(); // Espera a ambos\n    }\n}```"}
{"instruction": "Obtén el resultado del primero que termine con anyOf().", "response": "Útil para consultar múltiples fuentes y usar la respuesta más rápida.\n\n```java\nimport java.util.concurrent.CompletableFuture;\n\npublic class Carrera {\n    public static void main(String[] args) {\n        CompletableFuture<Object> ganador = CompletableFuture.anyOf(\n            CompletableFuture.supplyAsync(() -> { try{Thread.sleep(100);}catch(Exception e){}; return \"Lento\"; }),\n            CompletableFuture.supplyAsync(() -> \"Rápido\")\n        );\n        System.out.println(ganador.join()); // Rápido\n    }\n}```"}
{"instruction": "Obtén el tamaño de un archivo en bytes con Files.size().", "response": "Operación de IO para obtener metadatos del sistema de archivos.\n\n```java\nimport java.nio.file.*;\n\npublic class TamanoArchivo {\n    public static void main(String[] args) throws Exception {\n        Path p = Paths.get(\"foto.jpg\");\n        if (Files.exists(p)) {\n            System.out.println(Files.size(p) + \" bytes\");\n        }\n    }\n}```"}
{"instruction": "Borra un archivo solo si existe con deleteIfExists().", "response": "Evita lanzar `NoSuchFileException` si el archivo ya fue borrado.\n\n```java\nimport java.nio.file.*;\n\npublic class BorradoSeguro {\n    public static void borrar(Path p) throws Exception {\n        boolean borrado = Files.deleteIfExists(p);\n        System.out.println(\"¿Borrado? \" + borrado);\n    }\n}```"}
{"instruction": "Combina rutas de archivos con Path.resolve().", "response": "Forma correcta de construir rutas independientemente del sistema operativo.\n\n```java\nimport java.nio.file.*;\n\npublic class Rutas {\n    public static void main(String[] args) {\n        Path dir = Paths.get(\"/home/user\");\n        Path archivo = dir.resolve(\"docs/carta.txt\");\n        System.out.println(archivo); // /home/user/docs/carta.txt (en Linux)\n    }\n}```"}
{"instruction": "Calcula una ruta relativa entre dos Paths.", "response": "Encuentra el camino para ir de una ruta a otra.\n\n```java\nimport java.nio.file.*;\n\npublic class Relativo {\n    public static void main(String[] args) {\n        Path p1 = Paths.get(\"/a/b\");\n        Path p2 = Paths.get(\"/a/b/c/d\");\n        System.out.println(p1.relativize(p2)); // c/d\n    }\n}```"}
{"instruction": "Lee un archivo completo usando Scanner.", "response": "Útil para parsear tokens primitivos directamente de un archivo.\n\n```java\nimport java.util.Scanner;\nimport java.io.File;\n\npublic class LeerScanner {\n    public static void main(String[] args) throws Exception {\n        try (Scanner sc = new Scanner(new File(\"datos.txt\"))) {\n            while (sc.hasNext()) System.out.println(sc.next());\n        }\n    }\n}```"}
{"instruction": "Escribe texto formateado a un archivo con PrintWriter.", "response": "Permite usar `printf` y `println` escribiendo directamente a disco.\n\n```java\nimport java.io.PrintWriter;\n\npublic class EscrituraFormato {\n    public static void main(String[] args) throws Exception {\n        try (PrintWriter pw = new PrintWriter(\"log.txt\")) {\n            pw.printf(\"Usuario: %s, ID: %d\", \"Admin\", 1);\n        }\n    }\n}```"}
{"instruction": "Escribe datos binarios (primitivos) con DataOutputStream.", "response": "Permite guardar `int`, `double`, `boolean` de forma portátil.\n\n```java\nimport java.io.*;\n\npublic class BinarioIO {\n    public static void main(String[] args) throws Exception {\n        try (DataOutputStream dos = new DataOutputStream(new FileOutputStream(\"data.bin\"))) {\n            dos.writeInt(123);\n            dos.writeDouble(4.56);\n        }\n    }\n}```"}
{"instruction": "Serializa un objeto Java a un archivo.", "response": "Guarda el estado de un objeto que implementa `Serializable`.\n\n```java\nimport java.io.*;\n\npublic class GuardarObjeto {\n    public static void guardar(Serializable obj) throws Exception {\n        try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"obj.dat\"))) {\n            oos.writeObject(obj);\n        }\n    }\n}```"}
{"instruction": "Usa la interfaz BiConsumer para operar sobre dos argumentos.", "response": "Interfaz funcional que acepta dos parámetros y no devuelve nada (ej. para Maps).\n\n```java\nimport java.util.function.BiConsumer;\n\npublic class BiCons {\n    public static void main(String[] args) {\n        BiConsumer<String, Integer> imprimir = (k, v) -> System.out.println(k + \"=\" + v);\n        imprimir.accept(\"Edad\", 25);\n    }\n}```"}
{"instruction": "Usa ObjIntConsumer para evitar boxing en el segundo argumento.", "response": "Optimización para consumir un objeto y un `int` primitivo.\n\n```java\nimport java.util.function.ObjIntConsumer;\n\npublic class OptimizacionFunc {\n    public static void main(String[] args) {\n        ObjIntConsumer<String> repetir = (s, i) -> System.out.println(s.repeat(i));\n        repetir.accept(\"Hola\", 2);\n    }\n}```"}
{"instruction": "Usa ToIntFunction para extraer un entero de un objeto.", "response": "Comúnmente usada en Streams para mapear a `IntStream`.\n\n```java\nimport java.util.function.ToIntFunction;\n\npublic class Extractor {\n    public static void main(String[] args) {\n        ToIntFunction<String> len = String::length;\n        System.out.println(len.applyAsInt(\"Test\")); // 4\n    }\n}```"}
{"instruction": "Invierte un comparador existente con reversed().", "response": "Forma fluida de cambiar el orden de ascendente a descendente.\n\n```java\nimport java.util.*;\n\npublic class OrdenReversoComp {\n    public static void main(String[] args) {\n        Comparator<Integer> comp = Comparator.naturalOrder();\n        List<Integer> l = Arrays.asList(1, 5, 2);\n        l.sort(comp.reversed());\n        System.out.println(l); // [5, 2, 1]\n    }\n}```"}
{"instruction": "Usa Comparator.naturalOrder() para tipos Comparables.", "response": "Retorna un comparador que respeta el orden natural (Comparable) del tipo.\n\n```java\nimport java.util.*;\n\npublic class Natural {\n    public static void main(String[] args) {\n        List<String> nombres = Arrays.asList(\"B\", \"A\");\n        nombres.sort(Comparator.naturalOrder());\n        System.out.println(nombres); // [A, B]\n    }\n}```"}
{"instruction": "Usa WeakHashMap para mapas donde las claves pueden ser recolectadas.", "response": "Si la clave no tiene otras referencias, la entrada se elimina del mapa automáticamente.\n\n```java\nimport java.util.WeakHashMap;\n\npublic class MapaDebil {\n    public static void main(String[] args) {\n        WeakHashMap<Object, String> map = new WeakHashMap<>();\n        Object key = new Object();\n        map.put(key, \"Dato\");\n        key = null; // La entrada se borrará en el próximo GC\n        System.gc();\n    }\n}```"}
{"instruction": "Usa EnumMap para mapas donde las claves son Enums.", "response": "Implementación de Map altamente optimizada y compacta para Enums.\n\n```java\nimport java.util.EnumMap;\nenum Dia { LUN, MAR }\n\npublic class MapaEnum {\n    public static void main(String[] args) {\n        EnumMap<Dia, String> actividades = new EnumMap<>(Dia.class);\n        actividades.put(Dia.LUN, \"Trabajar\");\n        System.out.println(actividades.get(Dia.LUN));\n    }\n}```"}
{"instruction": "Usa los métodos de navegación de NavigableSet (pollFirst/pollLast).", "response": "Permite recuperar y eliminar el primer o último elemento eficientemente.\n\n```java\nimport java.util.TreeSet;\n\npublic class NavegacionSet {\n    public static void main(String[] args) {\n        TreeSet<Integer> set = new TreeSet<>(Arrays.asList(10, 20, 30));\n        System.out.println(set.pollFirst()); // 10\n        System.out.println(set.pollLast());  // 30\n    }\n}```"}
{"instruction": "Diferencia entre element() y peek() en Queue.", "response": "`element()` lanza excepción si la cola está vacía, `peek()` retorna null.\n\n```java\nimport java.util.*;\npublic class QueueCheck {\n    public static void main(String[] args) {\n        Queue<String> q = new LinkedList<>();\n        System.out.println(q.peek()); // null\n        // System.out.println(q.element()); // Lanza NoSuchElementException\n    }\n}```"}
{"instruction": "Usa Deque para agregar explícitamente al principio o final.", "response": "Interfaz doblemente terminada para operaciones claras de pila o cola.\n\n```java\nimport java.util.*;\npublic class DequeExplícito {\n    public static void main(String[] args) {\n        Deque<Integer> d = new LinkedList<>();\n        d.addFirst(1);\n        d.addLast(2);\n        System.out.println(d); // [1, 2]\n    }\n}```"}
{"instruction": "Encuentra el siguiente número primo probable con BigInteger.", "response": "Operación útil en criptografía para encontrar primos grandes cercanos.\n\n```java\nimport java.math.BigInteger;\n\npublic class SiguientePrimo {\n    public static void main(String[] args) {\n        BigInteger n = BigInteger.valueOf(100);\n        System.out.println(n.nextProbablePrime()); // 101\n    }\n}```"}
{"instruction": "Redondea un BigDecimal con escala específica.", "response": "Manejo preciso de decimales, especificando el modo de redondeo.\n\n```java\nimport java.math.*;\n\npublic class RedondeoPreciso {\n    public static void main(String[] args) {\n        BigDecimal bd = new BigDecimal(\"10.555\");\n        BigDecimal res = bd.setScale(2, RoundingMode.HALF_UP);\n        System.out.println(res); // 10.56\n    }\n}```"}
{"instruction": "Accede a un campo privado usando Reflexión.", "response": "Permite leer/escribir campos privados (rompiendo encapsulamiento, usar con cuidado).\n\n```java\nimport java.lang.reflect.Field;\n\nclass Secreto { private String clave = \"123\"; }\n\npublic class Hacker {\n    public static void main(String[] args) throws Exception {\n        Secreto s = new Secreto();\n        Field f = Secreto.class.getDeclaredField(\"clave\");\n        f.setAccessible(true);\n        System.out.println(f.get(s)); // 123\n    }\n}```"}
{"instruction": "Carga una clase dinámicamente con Class.forName().", "response": "Carga la clase en memoria por su nombre (String), usada en drivers JDBC.\n\n```java\npublic class CargaDinamica {\n    public static void main(String[] args) throws Exception {\n        Class<?> clazz = Class.forName(\"java.util.ArrayList\");\n        System.out.println(clazz.getName());\n    }\n}```"}
{"instruction": "Redirige la salida estándar (System.out) a un archivo.", "response": "Cambia el destino de `System.out.println`.\n\n```java\nimport java.io.*;\n\npublic class Redireccion {\n    public static void main(String[] args) throws Exception {\n        System.setOut(new PrintStream(new FileOutputStream(\"salida.txt\")));\n        System.out.println(\"Esto va al archivo\");\n    }\n}```"}
{"instruction": "Obtén la memoria total reservada por la JVM.", "response": "Diferente a la memoria libre; es lo que la JVM ha tomado del SO.\n\n```java\npublic class MemoriaTotal {\n    public static void main(String[] args) {\n        System.out.println(Runtime.getRuntime().totalMemory());\n    }\n}```"}
{"instruction": "Imprime la traza de pila (Stack Trace) del hilo actual.", "response": "Útil para depuración manual sin lanzar excepciones.\n\n```java\npublic class Traza {\n    public static void imprimirStack() {\n        for (StackTraceElement ste : Thread.currentThread().getStackTrace()) {\n            System.out.println(ste);\n        }\n    }\n}```"}
{"instruction": "Establece un manejador global para excepciones no capturadas.", "response": "Última línea de defensa para loguear errores que crashean hilos.\n\n```java\npublic class GlobalHandler {\n    public static void main(String[] args) {\n        Thread.setDefaultUncaughtExceptionHandler((t, e) -> \n            System.out.println(\"Hilo \" + t.getName() + \" falló: \" + e)\n        );\n        throw new RuntimeException(\"Boom\");\n    }\n}```"}
{"instruction": "Usa java.util.logging.Logger para registrar mensajes.", "response": "Sistema de logging nativo de Java (JUL).\n\n```java\nimport java.util.logging.*;\n\npublic class LogBasico {\n    private static final Logger logger = Logger.getLogger(LogBasico.class.getName());\n    public static void main(String[] args) {\n        logger.info(\"Mensaje informativo\");\n        logger.warning(\"Advertencia\");\n    }\n}```"}
{"instruction": "Retorna un Optional alternativo con or() (Java 9).", "response": "Permite encadenar Optionals: si el primero está vacío, intenta el segundo.\n\n```java\nimport java.util.Optional;\n\npublic class OpOr {\n    public static void main(String[] args) {\n        Optional<String> opt = Optional.empty();\n        // Si opt está vacío, retorna el Optional \"Plan B\"\n        Optional<String> res = opt.or(() -> Optional.of(\"Plan B\"));\n        System.out.println(res.get());\n    }\n}```"}
{"instruction": "Toma elementos de un Stream mientras se cumpla una condición (takeWhile - Java 9).", "response": "Corta el stream en cuanto el predicado falla (cortocircuito).\n\n```java\nimport java.util.stream.Stream;\n\npublic class TomarMientras {\n    public static void main(String[] args) {\n        Stream.of(1, 2, 3, 10, 4)\n              .takeWhile(n -> n < 10)\n              .forEach(System.out::print); // 123 (Se detiene en 10)\n    }\n}```"}
{"instruction": "Descarta elementos de un Stream hasta que falle la condición (dropWhile - Java 9).", "response": "Lo opuesto a `takeWhile`: salta elementos iniciales y toma el resto.\n\n```java\nimport java.util.stream.Stream;\n\npublic class SoltarMientras {\n    public static void main(String[] args) {\n        Stream.of(1, 2, 3, 10, 4)\n              .dropWhile(n -> n < 10)\n              .forEach(System.out::print); // 104 (Empieza desde 10)\n    }\n}```"}
{"instruction": "Usa Hilos Virtuales (Virtual Threads) de Java 21.", "response": "Hilos ultraligeros gestionados por la JVM, ideales para tareas de alto I/O.\n\n```java\npublic class VirtualThreads {\n    public static void main(String[] args) throws InterruptedException {\n        Thread vThread = Thread.ofVirtual().start(() -> {\n            System.out.println(\"Corriendo en hilo virtual: \" + Thread.currentThread());\n        });\n        vThread.join();\n    }\n}```"}
{"instruction": "Accede al primer y último elemento con SequencedCollections (Java 21).", "response": "Interfaz unificada para Listas, Deques y Sets ordenados que agrega `getFirst` y `getLast`.\n\n```java\nimport java.util.*;\n\npublic class Secuenciada {\n    public static void main(String[] args) {\n        List<String> lista = new ArrayList<>();\n        lista.add(\"A\");\n        lista.add(\"B\");\n        System.out.println(lista.getLast()); // B (Sin usar size()-1)\n    }\n}```"}
{"instruction": "Formatea datos binarios con HexFormat (Java 17).", "response": "API estándar para convertir bytes a Hex y viceversa, reemplazando librerías externas.\n\n```java\nimport java.util.HexFormat;\n\npublic class HexDemo {\n    public static void main(String[] args) {\n        byte[] bytes = {10, 20, 30};\n        String hex = HexFormat.of().formatHex(bytes);\n        System.out.println(hex); // 0a141e\n    }\n}```"}
{"instruction": "Formatea números decimales y moneda con DecimalFormat.", "response": "Permite controlar la cantidad de decimales y símbolos de agrupación.\n\n```java\nimport java.text.DecimalFormat;\n\npublic class Moneda {\n    public static void main(String[] args) {\n        DecimalFormat df = new DecimalFormat(\"#,###.00\");\n        System.out.println(df.format(12345.6789)); // 12.345,68 (según locale)\n    }\n}```"}
{"instruction": "Envía un paquete UDP con DatagramSocket.", "response": "Protocolo sin conexión, rápido pero no garantizado.\n\n```java\nimport java.net.*;\n\npublic class ClienteUDP {\n    public static void enviar() throws Exception {\n        DatagramSocket socket = new DatagramSocket();\n        byte[] buffer = \"Hola\".getBytes();\n        InetAddress address = InetAddress.getByName(\"localhost\");\n        DatagramPacket packet = new DatagramPacket(buffer, buffer.length, address, 9876);\n        socket.send(packet);\n        socket.close();\n    }\n}```"}
{"instruction": "Recibe paquetes UDP con DatagramSocket.", "response": "Escucha en un puerto específico paquetes entrantes.\n\n```java\nimport java.net.*;\n\npublic class ServidorUDP {\n    public static void main(String[] args) throws Exception {\n        DatagramSocket socket = new DatagramSocket(9876);\n        byte[] buffer = new byte[1024];\n        DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n        socket.receive(packet);\n        System.out.println(new String(packet.getData(), 0, packet.getLength()));\n    }\n}```"}
{"instruction": "Protege contra desbordamiento matemático con Math.multiplyExact().", "response": "Lanza `ArithmeticException` si el resultado no cabe en un int/long, en lugar de dar vueltas en silencio.\n\n```java\npublic class Seguro {\n    public static void main(String[] args) {\n        int x = 2_000_000_000;\n        try {\n            int res = Math.multiplyExact(x, 2);\n        } catch (ArithmeticException e) {\n            System.out.println(\"Overflow detectado\");\n        }\n    }\n}```"}
{"instruction": "Crea una vista segura de tipos con Collections.checkedList().", "response": "Verifica en tiempo de inserción que los elementos sean del tipo correcto (útil para código legacy sin generics).\n\n```java\nimport java.util.*;\n\npublic class Checked {\n    public static void main(String[] args) {\n        List rawList = new ArrayList();\n        List<String> checked = Collections.checkedList(rawList, String.class);\n        // checked.add(10); // Lanza ClassCastException inmediatamente\n    }\n}```"}
{"instruction": "Maneja errores en CompletableFuture con exceptionally().", "response": "Permite recuperar o loguear errores en una cadena de promesas asíncronas.\n\n```java\nimport java.util.concurrent.CompletableFuture;\n\npublic class ErrorAsync {\n    public static void main(String[] args) {\n        CompletableFuture.supplyAsync(() -> 1 / 0)\n            .exceptionally(ex -> {\n                System.out.println(\"Error: \" + ex.getMessage());\n                return 0;\n            }).thenAccept(System.out::println); // Imprime 0\n    }\n}```"}
{"instruction": "Encripta datos usando AES (Cipher).", "response": "Cifrado simétrico estándar.\n\n```java\nimport javax.crypto.Cipher;\nimport javax.crypto.spec.SecretKeySpec;\n\npublic class AES {\n    public static byte[] encriptar(String data, String key) throws Exception {\n        SecretKeySpec secretKey = new SecretKeySpec(key.getBytes(), \"AES\");\n        Cipher cipher = Cipher.getInstance(\"AES\");\n        cipher.init(Cipher.ENCRYPT_MODE, secretKey);\n        return cipher.doFinal(data.getBytes());\n    }\n}```"}
{"instruction": "Ordena Strings considerando acentos con Collator.", "response": "El orden ASCII pone 'Z' antes que 'á'. `Collator` respeta el idioma.\n\n```java\nimport java.text.Collator;\nimport java.util.*;\n\npublic class OrdenLatino {\n    public static void main(String[] args) {\n        List<String> palabras = Arrays.asList(\"Árbol\", \"Barco\");\n        Collections.sort(palabras, Collator.getInstance(Locale.getDefault()));\n        System.out.println(palabras); // [Árbol, Barco]\n    }\n}```"}
{"instruction": "Bloquea un archivo para acceso exclusivo con FileLock.", "response": "Mecanismo del SO para evitar que dos procesos escriban el mismo archivo a la vez.\n\n```java\nimport java.io.RandomAccessFile;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.FileLock;\n\npublic class CandadoArchivo {\n    public static void main(String[] args) throws Exception {\n        try (RandomAccessFile file = new RandomAccessFile(\"data.txt\", \"rw\");\n             FileChannel channel = file.getChannel()) {\n            FileLock lock = channel.lock(); // Bloquea\n            System.out.println(\"Archivo bloqueado\");\n            lock.release();\n        }\n    }\n}```"}
{"instruction": "Usa Memory Mapped Files para lectura ultra rápida de archivos grandes.", "response": "Mapea una región del archivo directamente a memoria virtual.\n\n```java\nimport java.nio.MappedByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.*;\n\npublic class Mmap {\n    public static void leer() throws Exception {\n        try (FileChannel ch = (FileChannel) Files.newByteChannel(Paths.get(\"big.dat\"))) {\n            MappedByteBuffer mb = ch.map(FileChannel.MapMode.READ_ONLY, 0, ch.size());\n            if (mb.hasRemaining()) System.out.println((char) mb.get());\n        }\n    }\n}```"}
{"instruction": "Ajusta la indentación de un String multilínea con indent() (Java 12).", "response": "Agrega o quita espacios al inicio de cada línea.\n\n```java\npublic class Indentacion {\n    public static void main(String[] args) {\n        String html = \"<div>\\n<p>\".indent(4);\n        System.out.print(html);\n        //    <div>\n        //    <p>\n    }\n}```"}
{"instruction": "Transforma un String in-place con transform() (Java 12).", "response": "Aplica una función al string y retorna el resultado, facilitando el encadenamiento.\n\n```java\npublic class Transform {\n    public static void main(String[] args) {\n        String res = \" hola \".transform(String::trim)\n                            .transform(s -> s + \" mundo\")\n                            .transform(String::toUpperCase);\n        System.out.println(res); // HOLA MUNDO\n    }\n}```"}
{"instruction": "Encuentra si una sublista existe dentro de una lista mayor.", "response": "`Collections.indexOfSubList` busca la secuencia exacta.\n\n```java\nimport java.util.*;\n\npublic class SubSecuencia {\n    public static void main(String[] args) {\n        List<Integer> fuente = Arrays.asList(1, 2, 3, 4, 5);\n        List<Integer> target = Arrays.asList(3, 4);\n        System.out.println(Collections.indexOfSubList(fuente, target)); // 2\n    }\n}```"}
{"instruction": "Itera sobre bits encendidos de un BitSet eficientemente.", "response": "`nextSetBit` salta los ceros, ideal para conjuntos dispersos.\n\n```java\nimport java.util.BitSet;\n\npublic class IterarBits {\n    public static void main(String[] args) {\n        BitSet bs = new BitSet();\n        bs.set(10); bs.set(100);\n        for (int i = bs.nextSetBit(0); i >= 0; i = bs.nextSetBit(i + 1)) {\n            System.out.println(\"Bit activo: \" + i);\n        }\n    }\n}```"}
{"instruction": "Recopila datos de un Stream en un Mapa manejando duplicados.", "response": "Si hay claves duplicadas, el tercer argumento (`mergeFunction`) decide qué valor conservar.\n\n```java\nimport java.util.stream.*;\nimport java.util.Map;\n\npublic class MapDuplicados {\n    public static void main(String[] args) {\n        Stream<String> s = Stream.of(\"a\", \"b\", \"a\");\n        // (v1, v2) -> v1 mantiene el primer valor encontrado\n        Map<String, Integer> map = s.collect(Collectors.toMap(k -> k, v -> 1, (v1, v2) -> v1));\n        System.out.println(map); // {a=1, b=1}\n    }\n}```"}
{"instruction": "Niega un Predicate existente con negate().", "response": "Invierte la lógica booleana del predicado original.\n\n```java\nimport java.util.function.Predicate;\n\npublic class Negacion {\n    public static void main(String[] args) {\n        Predicate<String> esVacio = String::isEmpty;\n        Predicate<String> noVacio = esVacio.negate();\n        System.out.println(noVacio.test(\"Texto\")); // true\n    }\n}```"}
{"instruction": "Compone funciones con compose() y andThen().", "response": "`andThen` ejecuta después, `compose` ejecuta antes.\n\n```java\nimport java.util.function.Function;\n\npublic class Composicion {\n    public static void main(String[] args) {\n        Function<Integer, Integer> porDos = x -> x * 2;\n        Function<Integer, Integer> masUno = x -> x + 1;\n        \n        // (5 * 2) + 1 = 11\n        System.out.println(porDos.andThen(masUno).apply(5));\n    }\n}```"}
{"instruction": "Genera una cadena alfanumérica aleatoria.", "response": "Uso común para tokens o contraseñas temporales.\n\n```java\nimport java.util.Random;\n\npublic class TokenGen {\n    public static void main(String[] args) {\n        String chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\n        Random rnd = new Random();\n        StringBuilder sb = new StringBuilder();\n        for(int i=0; i<8; i++) \n            sb.append(chars.charAt(rnd.nextInt(chars.length())));\n        System.out.println(sb.toString());\n    }\n}```"}
{"instruction": "Verifica si un archivo está oculto con NIO.", "response": "Abstracción sobre el sistema de archivos (funciona en Windows y Linux).\n\n```java\nimport java.nio.file.*;\n\npublic class Oculto {\n    public static void main(String[] args) throws Exception {\n        Path p = Paths.get(\".gitignore\");\n        System.out.println(Files.isHidden(p));\n    }\n}```"}
{"instruction": "Obtén el propietario (Owner) de un archivo.", "response": "Lectura de atributos de seguridad del archivo.\n\n```java\nimport java.nio.file.*;\nimport java.nio.file.attribute.UserPrincipal;\n\npublic class DuenoArchivo {\n    public static void main(String[] args) throws Exception {\n        Path p = Paths.get(\"test.txt\");\n        UserPrincipal owner = Files.getOwner(p);\n        System.out.println(owner.getName());\n    }\n}```"}
{"instruction": "Monitorea cambios en un directorio con WatchService.", "response": "Notifica eventos de creación, modificación o borrado de archivos en tiempo real.\n\n```java\nimport java.nio.file.*;\n\npublic class MonitorDir {\n    public static void main(String[] args) throws Exception {\n        WatchService ws = FileSystems.getDefault().newWatchService();\n        Paths.get(\".\").register(ws, StandardWatchEventKinds.ENTRY_CREATE);\n        // Espera un evento (bloqueante)\n        WatchKey key = ws.take();\n        key.pollEvents().forEach(e -> System.out.println(e.context()));\n    }\n}```"}
{"instruction": "Descomprime un archivo ZIP con ZipInputStream.", "response": "Lee secuencialmente las entradas de un archivo comprimido.\n\n```java\nimport java.util.zip.*;\nimport java.io.*;\n\npublic class Unzip {\n    public static void leerZip(String ruta) throws Exception {\n        try (ZipInputStream zis = new ZipInputStream(new FileInputStream(ruta))) {\n            ZipEntry entry;\n            while ((entry = zis.getNextEntry()) != null) {\n                System.out.println(\"Archivo: \" + entry.getName());\n            }\n        }\n    }\n}```"}
{"instruction": "Comprime datos en memoria con GZIPOutputStream.", "response": "Compresión rápida para streams de bytes.\n\n```java\nimport java.util.zip.GZIPOutputStream;\nimport java.io.ByteArrayOutputStream;\n\npublic class GzipMem {\n    public static byte[] comprimir(String data) throws Exception {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        try (GZIPOutputStream gzip = new GZIPOutputStream(baos)) {\n            gzip.write(data.getBytes());\n        }\n        return baos.toByteArray();\n    }\n}```"}
{"instruction": "Codifica en Base64 seguro para URLs (URL Safe).", "response": "Reemplaza caracteres `+` y `/` por `-` y `_` para uso seguro en direcciones web.\n\n```java\nimport java.util.Base64;\n\npublic class Base64Url {\n    public static void main(String[] args) {\n        String url = Base64.getUrlEncoder().encodeToString(\"a?b\".getBytes());\n        System.out.println(url);\n    }\n}```"}
{"instruction": "Construye Strings complejos con StringJoiner (Bajo nivel).", "response": "Clase base que `String.join` y los Collectors usan internamente. Permite prefijos y sufijos.\n\n```java\nimport java.util.StringJoiner;\n\npublic class Joiner {\n    public static void main(String[] args) {\n        StringJoiner sj = new StringJoiner(\", \", \"[\", \"]\");\n        sj.add(\"A\").add(\"B\");\n        System.out.println(sj); // [A, B]\n    }\n}```"}
{"instruction": "Escapa literales para Regex con Pattern.quote().", "response": "Trata cualquier cadena como texto literal, ignorando metacaracteres regex (`*`, `?`, etc.).\n\n```java\nimport java.util.regex.Pattern;\n\npublic class EscapeRegex {\n    public static void main(String[] args) {\n        String input = \"1.5*2\";\n        // Busca literalmente \"1.5*2\", no el comodín *\n        System.out.println(input.matches(Pattern.quote(input))); // true\n    }\n}```"}
{"instruction": "Configura un delimitador personalizado en Scanner.", "response": "Por defecto usa espacios, pero se puede configurar para CSV (comas) u otros.\n\n```java\nimport java.util.Scanner;\n\npublic class CsvScan {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(\"A,B,C\").useDelimiter(\",\");\n        while(sc.hasNext()) System.out.println(sc.next());\n    }\n}```"}
{"instruction": "Ejecuta comandos del sistema con Runtime.exec() (Básico).", "response": "Manera antigua de ejecutar procesos (se prefiere ProcessBuilder, pero útil conocerla).\n\n```java\npublic class ExecDemo {\n    public static void main(String[] args) throws Exception {\n        Process p = Runtime.getRuntime().exec(\"java -version\");\n        p.waitFor();\n    }\n}```"}
{"instruction": "Obtén el separador de línea del sistema operativo actual.", "response": "Evita hardcodear `\\n` (Unix) o `\\r\\n` (Windows).\n\n```java\npublic class SaltoLinea {\n    public static void main(String[] args) {\n        String eol = System.lineSeparator();\n        System.out.print(\"Hola\" + eol + \"Mundo\");\n    }\n}```"}
{"instruction": "Comparar Doubles correctamente manejando NaN e Infinito.", "response": "`Double.compare` maneja casos especiales que los operadores `<`, `>` ignoran o manejan diferente.\n\n```java\npublic class CompararDouble {\n    public static void main(String[] args) {\n        // Double.NaN > Double.POSITIVE_INFINITY en Double.compare\n        System.out.println(Double.compare(Double.NaN, Double.POSITIVE_INFINITY)); // 1\n    }\n}```"}
{"instruction": "Obtén la representación en bits de un float.", "response": "Útil para manipulación a bajo nivel o hashing de flotantes.\n\n```java\npublic class BitsFloat {\n    public static void main(String[] args) {\n        int bits = Float.floatToIntBits(10.5f);\n        System.out.println(Integer.toBinaryString(bits));\n    }\n}```"}
{"instruction": "Realiza un Casting dinámico con Class.cast().", "response": "Alternativa al operador de casting `(Type) obj` cuando la clase se conoce en runtime.\n\n```java\npublic class CastDinamico {\n    public static void main(String[] args) {\n        Object obj = \"Texto\";\n        String s = String.class.cast(obj);\n        System.out.println(s);\n    }\n}```"}
{"instruction": "Crea un Proxy Dinámico para interceptar llamadas a métodos.", "response": "Permite envolver una interfaz y ejecutar lógica antes/después de cada método.\n\n```java\nimport java.lang.reflect.*;\n\ninterface IService { void run(); }\n\npublic class ProxyDemo {\n    public static void main(String[] args) {\n        IService proxy = (IService) Proxy.newProxyInstance(\n            IService.class.getClassLoader(),\n            new Class[]{IService.class},\n            (p, method, a) -> { System.out.println(\"Interceptado\"); return null; }\n        );\n        proxy.run();\n    }\n}```"}
{"instruction": "Usa MethodHandles para reflexión moderna y rápida.", "response": "API más segura y eficiente que la reflexión tradicional `Method.invoke`.\n\n```java\nimport java.lang.invoke.*;\n\npublic class HandleDemo {\n    public static void main(String[] args) throws Throwable {\n        MethodHandles.Lookup lookup = MethodHandles.lookup();\n        MethodHandle mh = lookup.findVirtual(String.class, \"length\", MethodType.methodType(int.class));\n        System.out.println((int) mh.invokeExact(\"Java\")); // 4\n    }\n}```"}
{"instruction": "Inspecciona la pila de llamadas con StackWalker (Java 9).", "response": "Forma eficiente y Stream-friendly de recorrer el stack trace.\n\n```java\nimport java.lang.StackWalker;\n\npublic class PilaModerna {\n    public static void main(String[] args) {\n        StackWalker.getInstance().forEach(frame -> \n            System.out.println(frame.getClassName() + \"/\" + frame.getMethodName())\n        );\n    }\n}```"}
{"instruction": "Usa Spliterator para recorrer y dividir datos en paralelo.", "response": "Componente fundamental de los Streams paralelos, permite dividir la fuente de datos.\n\n```java\nimport java.util.*;\n\npublic class SpliteratorDemo {\n    public static void main(String[] args) {\n        List<String> l = Arrays.asList(\"A\", \"B\", \"C\");\n        Spliterator<String> split = l.spliterator();\n        split.tryAdvance(System.out::println); // A\n    }\n}```"}
{"instruction": "Carga un servicio con ServiceLoader (SPI).", "response": "Mecanismo estándar de Java para inyección de dependencias modular y plugins.\n\n```java\nimport java.util.ServiceLoader;\n\n// interface Driver {}\npublic class CargarPlugins {\n    public static void main(String[] args) {\n        // Carga implementaciones de Driver declaradas en META-INF/services\n        // ServiceLoader<Driver> loader = ServiceLoader.load(Driver.class);\n    }\n}```"}
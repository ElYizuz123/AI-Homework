{"instruction": "Explica qué es un algoritmo y da un ejemplo simple.", "response": "Un algoritmo es una secuencia ordenada de pasos para resolver un problema. Ejemplo: para sumar dos números, el algoritmo sería: leer A y B, calcular C = A + B, mostrar C."}
{"instruction": "Explica qué es una variable en programación.", "response": "Una variable es un espacio en memoria donde se almacena un valor que puede cambiar durante la ejecución del programa."}
{"instruction": "Dime qué es la complejidad temporal.", "response": "La complejidad temporal mide cuánto tiempo tarda un algoritmo en ejecutarse en función del tamaño de la entrada. Se expresa con notación Big O."}
{"instruction": "Explica la diferencia entre un arreglo y una lista enlazada.", "response": "Un arreglo almacena elementos contiguos en memoria y permite acceso directo O(1). Una lista enlazada almacena nodos dispersos unidos por punteros, con inserciones rápidas pero acceso secuencial O(n)."}
{"instruction": "Corrige este error en C: printf(\"%d\",x)", "response": "Falta el punto y coma al final. Debe quedar: printf(\"%d\", x);"}
{"instruction": "Muestra un ejemplo simple de recursión.", "response": "Ejemplo: función factorial. factorial(n) = 1 si n=1; de lo contrario, n * factorial(n-1). La función se llama a sí misma hasta alcanzar el caso base."}
{"instruction": "Explica qué es el caso base en una función recursiva.", "response": "El caso base es la condición que detiene la recursión. Evita llamadas infinitas. Por ejemplo, en factorial, el caso base es cuando n == 0."}
{"instruction": "Da un pseudocódigo para buscar un elemento con búsqueda lineal.", "response": "Para i desde 0 hasta n-1: si A[i] == x entonces retornar i. Fin para. Si no se encontró, retornar -1."}
{"instruction": "Explica el funcionamiento de la búsqueda binaria.", "response": "La búsqueda binaria divide repetidamente el arreglo ordenado por la mitad. Compara el elemento medio con el objetivo y descarta la mitad donde no puede estar."}
{"instruction": "Explica qué es un árbol binario.", "response": "Un árbol binario es una estructura donde cada nodo tiene máximo dos hijos: izquierdo y derecho. Se usa para organizar datos jerárquicamente."}
{"instruction": "Dame el recorrido en preorden de un árbol binario.", "response": "El recorrido en preorden visita: 1) nodo actual, 2) subárbol izquierdo, 3) subárbol derecho."}
{"instruction": "Qué es un grafo en algoritmos?", "response": "Un grafo es una estructura formada por nodos (vértices) conectados mediante aristas. Puede ser dirigido o no dirigido, y se usa para modelar relaciones."}
{"instruction": "Explica qué es BFS.", "response": "BFS (Breadth First Search) recorre un grafo por niveles, usando una cola. Es útil para encontrar rutas más cortas en grafos no ponderados."}
{"instruction": "Explica qué es DFS.", "response": "DFS (Depth First Search) recorre un grafo profundizando primero en un camino antes de retroceder. Usa una pila o recursión."}
{"instruction": "Dame un ejemplo de algoritmo greedy.", "response": "El algoritmo de selección de actividades es greedy: selecciona siempre la actividad que termina más pronto para maximizar el número total de actividades."}
{"instruction": "Qué es programación dinámica?", "response": "La programación dinámica resuelve problemas dividiéndolos en subproblemas que se resuelven una sola vez y se almacenan para evitar recomputación."}
{"instruction": "Describe el algoritmo de Kadane.", "response": "Kadane encuentra la suma máxima de un subarreglo en O(n), manteniendo un acumulador actual y el máximo encontrado."}
{"instruction": "Corrige este error en Python: if x = 5:", "response": "En Python se usa == para comparar. Debe ser: if x == 5:"}
{"instruction": "Explica qué es un heap.", "response": "Un heap es una estructura tipo árbol donde cada nodo cumple una propiedad: en un max-heap, cada nodo es mayor que sus hijos. Se usa para colas de prioridad."}
{"instruction": "Da el pseudocódigo de selección directa (selection sort).", "response": "Para i en 0..n-2: encontrar el índice del mínimo en i..n-1; intercambiar A[i] con A[minIdx]."}
{"instruction": "Explica por qué merge sort es eficiente.", "response": "Merge sort divide el arreglo en mitades hasta tamaños pequeños y luego las combina ordenadamente. Su complejidad siempre es O(n log n), independientemente de la entrada."}
{"instruction": "Qué es un algoritmo estable de ordenamiento?", "response": "Un algoritmo estable mantiene el orden relativo de elementos con el mismo valor. Merge sort y bubble sort son estables; quicksort no lo es por defecto."}
{"instruction": "Explica el peor caso de quicksort.", "response": "El peor caso ocurre cuando el pivote divide de forma muy desigual, generando complejidad O(n^2). Ocurre si el arreglo está ya ordenado y el pivote es el primer elemento."}
{"instruction": "Ayúdame a entender cómo funciona la cola (queue).", "response": "Una cola es una estructura FIFO (First In, First Out). Los elementos se insertan al final y se eliminan desde el frente."}
{"instruction": "Explica qué es una pila (stack).", "response": "Una pila es una estructura LIFO (Last In, First Out). Los elementos se agregan y retiran del tope."}
{"instruction": "Cómo detecto un ciclo en un grafo?", "response": "En grafos dirigidos se usa DFS con marcas de visitado y pila de recursión. Si un nodo vuelve a aparecer en la pila, hay un ciclo."}
{"instruction": "Qué es la técnica divide y vencerás?", "response": "Divide y vencerás consiste en dividir un problema en subproblemas más pequeños, resolverlos y combinar sus soluciones. Ejemplos: merge sort, quicksort."}
{"instruction": "Describe Dijkstra.", "response": "Dijkstra calcula la ruta más corta desde un nodo origen en un grafo con pesos positivos usando una cola de prioridad."}
{"instruction": "Explica Bellman-Ford.", "response": "Bellman-Ford encuentra rutas más cortas incluso con pesos negativos, relajando todas las aristas por n-1 iteraciones."}
{"instruction": "Corrige este código: for(i=0; i<n; i++); { printf(\"hola\"); }", "response": "El punto y coma después del for provoca un bucle vacío. Debes quitarlo: for(i=0; i<n; i++) { printf(\"hola\"); }"}
{"instruction": "Da un ejemplo de memoización.", "response": "En recursión del Fibonacci, almacenar fib(n) después de calcularlo permite evitar recomputación: if n in memo: return memo[n]."}
{"instruction": "Explica el principio del hashing.", "response": "Hashing convierte una clave en un índice mediante una función hash. Permite búsquedas promedio O(1) en tablas hash."}
{"instruction": "Qué es un árbol AVL?", "response": "Un árbol AVL es un árbol binario de búsqueda auto-balanceado que mantiene la diferencia de alturas entre subárboles en -1, 0 o 1."}
{"instruction": "Cómo funciona el algoritmo de Floyd-Warshall?", "response": "Floyd-Warshall calcula rutas más cortas entre todos los pares de nodos mediante programación dinámica en O(n^3)."}
{"instruction": "Dame un ejercicio básico de análisis de complejidad.", "response": "Ejercicio: ¿Cuál es la complejidad de un doble ciclo for anidado de 0 a n? Respuesta: O(n^2)."}
{"instruction": "Genera pseudocódigo para invertir un arreglo.", "response": "i=0, j=n-1; mientras i<j: intercambiar A[i] y A[j]; i++; j--."}
{"instruction": "Explica qué es una matriz de adyacencia.", "response": "Es una matriz donde cada celda (i,j) indica si hay arista entre los nodos i y j. Es útil para grafos densos."}
{"instruction": "Explica qué es una lista de adyacencia.", "response": "Es una lista donde cada nodo almacena una lista con sus vecinos. Es eficiente para grafos dispersos."}
{"instruction": "Realiza una explicación clara del algoritmo de burbuja.", "response": "Bubble sort compara pares consecutivos e intercambia si están en el orden incorrecto. Repite pasadas hasta que no haya intercambios."}
{"instruction": "Corrige este error en Java: int x = \"hola\";", "response": "No se puede asignar una cadena a un entero. Debe ser int x = 5; o usar String x = \"hola\";."}
{"instruction": "Explica qué es una cola de prioridad.", "response": "Una cola de prioridad extrae siempre el elemento de mayor o menor prioridad. Suele implementarse con heaps."}
{"instruction": "Dame un ejemplo de interacción tutor-estudiante sobre recursión.", "response": "Estudiante: ¿Por qué mi función no termina? Tutor: Porque no definiste un caso base. La función se llama infinitamente. Agrega una condición que detenga la recursión."}
{"instruction": "Genera un ejercicio para practicar BFS.", "response": "Dado un grafo no dirigido, encuentra la distancia mínima desde el nodo 0 a todos los demás usando BFS."}
{"instruction": "Explica qué es una función pura.", "response": "Una función pura siempre produce la misma salida con la misma entrada y no causa efectos secundarios."}
{"instruction": "Qué es un algoritmo determinista?", "response": "Es un algoritmo que siempre produce el mismo resultado con la misma entrada y sigue un flujo de ejecución fijo."}
{"instruction": "Da un ejemplo de algoritmo no determinista.", "response": "Un algoritmo que elige un vértice aleatorio en cada paso es no determinista porque su comportamiento depende del azar."}
{"instruction": "Describe un ejemplo clásico de programación dinámica.", "response": "El problema de la mochila 0/1 se resuelve con DP creando una tabla donde dp[i][w] representa el mejor valor usando los primeros i elementos y peso máximo w."}
{"instruction": "Explica qué es backtracking.", "response": "Backtracking explora soluciones parcializadas y retrocede ('backtrack') cuando una ruta no puede llevar a una solución válida. Ejemplo: resolver el sudoku."}
{"instruction": "Explica por qué usar estructuras de datos eficientes importa.", "response": "Elegir estructuras eficientes mejora el rendimiento. Por ejemplo, usar una tabla hash en lugar de una lista para búsquedas reduce el tiempo de O(n) a O(1)."}
{"instruction": "Dame un pseudocódigo de inserción en un árbol binario de búsqueda.", "response": "Si el árbol está vacío, insertar en la raíz. Si el valor es menor que el nodo, insertar a la izquierda; si es mayor, a la derecha; repetir recursivamente."}

{"instruction": "Explica qué es un algoritmo y da un ejemplo simple.", "response": "Un algoritmo es una secuencia ordenada de pasos para resolver un problema. Ejemplo: para sumar dos números, el algoritmo sería: leer A y B, calcular C = A + B, mostrar C."}
{"instruction": "Explica qué es una variable en programación.", "response": "Una variable es un espacio en memoria donde se almacena un valor que puede cambiar durante la ejecución del programa."}
{"instruction": "Dime qué es la complejidad temporal.", "response": "La complejidad temporal mide cuánto tiempo tarda un algoritmo en ejecutarse en función del tamaño de la entrada. Se expresa con notación Big O."}
{"instruction": "Explica la diferencia entre un arreglo y una lista enlazada.", "response": "Un arreglo almacena elementos contiguos en memoria y permite acceso directo O(1). Una lista enlazada almacena nodos dispersos unidos por punteros, con inserciones rápidas pero acceso secuencial O(n)."}
{"instruction": "Corrige este error en C: printf(\"%d\",x)", "response": "Falta el punto y coma al final y asegurar que x esté declarado. Debe quedar: printf(\"%d\", x);"}
{"instruction": "Muestra un ejemplo simple de recursión.", "response": "Ejemplo: función factorial. factorial(n) = 1 si n=1; de lo contrario, n * factorial(n-1). La función se llama a sí misma hasta alcanzar el caso base."}
{"instruction": "Explica qué es el caso base en una función recursiva.", "response": "El caso base es la condición que detiene la recursión. Evita llamadas infinitas. Por ejemplo, en factorial, el caso base es cuando n == 0."}
{"instruction": "Da un pseudocódigo para buscar un elemento con búsqueda lineal.", "response": "Para i desde 0 hasta n-1: si A[i] == x entonces retornar i. Fin para. Si no se encontró, retornar -1."}
{"instruction": "Explica el funcionamiento de la búsqueda binaria.", "response": "La búsqueda binaria divide repetidamente el arreglo ordenado por la mitad. Compara el elemento medio con el objetivo y descarta la mitad donde no puede estar."}
{"instruction": "Explica qué es un árbol binario.", "response": "Un árbol binario es una estructura donde cada nodo tiene máximo dos hijos: izquierdo y derecho. Se usa para organizar datos jerárquicamente."}
{"instruction": "Dame el recorrido en preorden de un árbol binario.", "response": "El recorrido en preorden visita: 1) nodo actual, 2) subárbol izquierdo, 3) subárbol derecho."}
{"instruction": "Qué es un grafo en algoritmos?", "response": "Un grafo es una estructura formada por nodos (vértices) conectados mediante aristas. Puede ser dirigido o no dirigido, y se usa para modelar relaciones."}
{"instruction": "Explica qué es BFS.", "response": "BFS (Breadth First Search) recorre un grafo por niveles, usando una cola. Es útil para encontrar rutas más cortas en grafos no ponderados."}
{"instruction": "Explica qué es DFS.", "response": "DFS (Depth First Search) recorre un grafo profundizando primero en un camino antes de retroceder. Usa una pila o recursión."}
{"instruction": "Dame un ejemplo de algoritmo greedy.", "response": "El algoritmo de selección de actividades es greedy: selecciona siempre la actividad que termina más pronto para maximizar el número total de actividades."}
{"instruction": "Qué es programación dinámica?", "response": "La programación dinámica resuelve problemas dividiéndolos en subproblemas que se resuelven una sola vez y se almacenan para evitar recomputación."}
{"instruction": "Describe el algoritmo de Kadane.", "response": "Kadane encuentra la suma máxima de un subarreglo en O(n), manteniendo un acumulador actual y el máximo encontrado."}
{"instruction": "Corrige este error en Python: if x = 5:", "response": "En Python se usa == para comparar. Debe ser: if x == 5:"}
{"instruction": "Explica qué es un heap.", "response": "Un heap es una estructura tipo árbol donde cada nodo cumple una propiedad: en un max-heap, cada nodo es mayor que sus hijos. Se usa para colas de prioridad."}
{"instruction": "Da el pseudocódigo de selección directa (selection sort).", "response": "Para i en 0..n-2: encontrar el índice del mínimo en i..n-1; intercambiar A[i] con A[minIdx]."}
{"instruction": "Explica por qué merge sort es eficiente.", "response": "Merge sort divide el arreglo en mitades hasta tamaños pequeños y luego las combina ordenadamente. Su complejidad siempre es O(n log n), independientemente de la entrada."}
{"instruction": "Qué es un algoritmo estable de ordenamiento?", "response": "Un algoritmo estable mantiene el orden relativo de elementos con el mismo valor. Merge sort y bubble sort son estables; quicksort no lo es por defecto."}
{"instruction": "Explica el peor caso de quicksort.", "response": "El peor caso ocurre cuando el pivote divide de forma muy desigual, generando complejidad O(n^2). Ocurre si el arreglo está ya ordenado y el pivote es el primer elemento."}
{"instruction": "Ayúdame a entender cómo funciona la cola (queue).", "response": "Una cola es una estructura FIFO (First In, First Out). Los elementos se insertan al final y se eliminan desde el frente."}
{"instruction": "Explica qué es una pila (stack).", "response": "Una pila es una estructura LIFO (Last In, First Out). Los elementos se agregan y retiran del tope."}
{"instruction": "Cómo detecto un ciclo en un grafo?", "response": "En grafos dirigidos se usa DFS con marcas de visitado y pila de recursión. Si un nodo vuelve a aparecer en la pila, hay un ciclo."}
{"instruction": "Qué es la técnica divide y vencerás?", "response": "Divide y vencerás consiste en dividir un problema en subproblemas más pequeños, resolverlos y combinar sus soluciones. Ejemplos: merge sort, quicksort."}
{"instruction": "Describe Dijkstra.", "response": "Dijkstra calcula la ruta más corta desde un nodo origen en un grafo con pesos positivos usando una cola de prioridad."}
{"instruction": "Explica Bellman-Ford.", "response": "Bellman-Ford encuentra rutas más cortas incluso con pesos negativos, relajando todas las aristas por n-1 iteraciones."}
{"instruction": "Corrige este código: for(i=0; i<n; i++); { printf(\"hola\"); }", "response": "El punto y coma después del for provoca un bucle vacío. Debes quitarlo: for(i=0; i<n; i++) { printf(\"hola\"); }"}
{"instruction": "Da un ejemplo de memoización.", "response": "En recursión del Fibonacci, almacenar fib(n) después de calcularlo permite evitar recomputación: if n in memo: return memo[n]."}
{"instruction": "Explica el principio del hashing.", "response": "Hashing convierte una clave en un índice mediante una función hash. Permite búsquedas promedio O(1) en tablas hash."}
{"instruction": "Qué es un árbol AVL?", "response": "Un árbol AVL es un árbol binario de búsqueda auto-balanceado que mantiene la diferencia de alturas entre subárboles en -1, 0 o 1."}
{"instruction": "Cómo funciona el algoritmo de Floyd-Warshall?", "response": "Floyd-Warshall calcula rutas más cortas entre todos los pares de nodos mediante programación dinámica en O(n^3)."}
{"instruction": "Dame un ejercicio básico de análisis de complejidad.", "response": "Ejercicio: ¿Cuál es la complejidad de un doble ciclo for anidado de 0 a n? Respuesta: O(n^2)."}
{"instruction": "Genera pseudocódigo para invertir un arreglo.", "response": "i=0, j=n-1; mientras i<j: intercambiar A[i] y A[j]; i++; j--."}
{"instruction": "Explica qué es una matriz de adyacencia.", "response": "Es una matriz donde cada celda (i,j) indica si hay arista entre los nodos i y j. Es útil para grafos densos."}
{"instruction": "Explica qué es una lista de adyacencia.", "response": "Es una lista donde cada nodo almacena una lista con sus vecinos. Es eficiente para grafos dispersos."}
{"instruction": "Realiza una explicación clara del algoritmo de burbuja.", "response": "Bubble sort compara pares consecutivos e intercambia si están en el orden incorrecto. Repite pasadas hasta que no haya intercambios."}
{"instruction": "Corrige este error en Java: int x = \"hola\";", "response": "No se puede asignar una cadena a un entero. Debe ser int x = 5; o usar String x = \"hola\";."}
{"instruction": "Explica qué es una cola de prioridad.", "response": "Una cola de prioridad extrae siempre el elemento de mayor o menor prioridad. Suele implementarse con heaps."}
{"instruction": "Dame un ejemplo de interacción tutor-estudiante sobre recursión.", "response": "Estudiante: ¿Por qué mi función no termina? Tutor: Porque no definiste un caso base. La función se llama infinitamente. Agrega una condición que detenga la recursión."}
{"instruction": "Genera un ejercicio para practicar BFS.", "response": "Dado un grafo no dirigido, encuentra la distancia mínima desde el nodo 0 a todos los demás usando BFS."}
{"instruction": "Explica qué es una función pura.", "response": "Una función pura siempre produce la misma salida con la misma entrada y no causa efectos secundarios."}
{"instruction": "Qué es un algoritmo determinista?", "response": "Es un algoritmo que siempre produce el mismo resultado con la misma entrada y sigue un flujo de ejecución fijo."}
{"instruction": "Da un ejemplo de algoritmo no determinista.", "response": "Un algoritmo que elige un vértice aleatorio en cada paso es no determinista porque su comportamiento depende del azar."}
{"instruction": "Describe un ejemplo clásico de programación dinámica.", "response": "El problema de la mochila 0/1 se resuelve con DP creando una tabla donde dp[i][w] representa el mejor valor usando los primeros i elementos y peso máximo w."}
{"instruction": "Explica qué es backtracking.", "response": "Backtracking explora soluciones parcializadas y retrocede ('backtrack') cuando una ruta no puede llevar a una solución válida. Ejemplo: resolver el sudoku."}
{"instruction": "Explica por qué usar estructuras de datos eficientes importa.", "response": "Elegir estructuras eficientes mejora el rendimiento. Por ejemplo, usar una tabla hash en lugar de una lista para búsquedas reduce el tiempo de O(n) a O(1)."}
{"instruction": "Dame un pseudocódigo de inserción en un árbol binario de búsqueda.", "response": "Si el árbol está vacío, insertar en la raíz. Si el valor es menor que el nodo, insertar a la izquierda; si es mayor, a la derecha; repetir recursivamente."}
{"instruction": "Explica qué es la complejidad espacial.", "response": "La complejidad espacial mide cuánta memoria adicional necesita un algoritmo para ejecutarse en relación con el tamaño de la entrada."}
{"instruction": "Qué es un desbordamiento de pila (Stack Overflow)?", "response": "Ocurre cuando se agota la memoria de la pila, comúnmente por una recursión infinita o demasiado profunda sin caso base."}
{"instruction": "Explica el concepto de 'scope' o ámbito de una variable.", "response": "El scope define dónde es accesible una variable. Puede ser local (dentro de una función) o global (accesible en todo el programa)."}
{"instruction": "Qué es una colisión en una tabla hash?", "response": "Una colisión ocurre cuando la función hash asigna el mismo índice a dos claves diferentes. Se resuelve con encadenamiento o direccionamiento abierto."}
{"instruction": "Describe el algoritmo Insertion Sort.", "response": "Insertion Sort construye el arreglo ordenado uno a uno, tomando un elemento y colocándolo en su posición correcta dentro de la parte ya ordenada."}
{"instruction": "Cuál es la diferencia entre un proceso y un hilo?", "response": "Un proceso es una instancia de un programa con su propia memoria. Un hilo es una unidad de ejecución dentro de un proceso que comparte memoria con otros hilos."}
{"instruction": "Explica qué es la herencia en POO.", "response": "La herencia permite crear una nueva clase basada en una existente, heredando sus atributos y métodos, lo que promueve la reutilización de código."}
{"instruction": "Qué es el polimorfismo en programación?", "response": "Es la capacidad de objetos de diferentes clases de responder al mismo mensaje o método de maneras distintas."}
{"instruction": "Explica el concepto de encapsulamiento.", "response": "El encapsulamiento oculta los detalles internos del estado de un objeto y solo expone lo necesario a través de métodos públicos."}
{"instruction": "Corrige este error lógico: while(x > 0) { print(x); } (x nunca cambia).", "response": "Es un bucle infinito. Debes decrementar x dentro del bucle: while(x > 0) { print(x); x--; }"}
{"instruction": "Qué es un algoritmo in-place?", "response": "Es un algoritmo que transforma la entrada usando una cantidad de memoria extra constante O(1), sin necesitar estructuras auxiliares grandes."}
{"instruction": "Explica el problema del vendedor viajero (TSP).", "response": "TSP busca la ruta más corta posible que visita cada ciudad exactamente una vez y regresa a la ciudad origen. Es un problema NP-hard."}
{"instruction": "Qué es un árbol de expansión mínima (MST)?", "response": "Es un subgrafo que conecta todos los vértices de un grafo con el peso total mínimo posible de las aristas y sin ciclos."}
{"instruction": "Explica el algoritmo de Kruskal.", "response": "Kruskal construye un MST ordenando las aristas por peso y añadiéndolas si no forman un ciclo (usando Union-Find)."}
{"instruction": "Explica el algoritmo de Prim.", "response": "Prim construye un MST comenzando desde un nodo arbitrario y agregando siempre la arista más barata que conecta un nodo visitado con uno no visitado."}
{"instruction": "Qué es una lista doblemente enlazada?", "response": "Es una lista donde cada nodo tiene referencias tanto al nodo siguiente como al anterior, permitiendo recorrido bidireccional."}
{"instruction": "Explica qué es un Trie (árbol de prefijos).", "response": "Un Trie es un árbol usado para almacenar strings de manera eficiente, donde cada nodo representa un carácter. Es ideal para autocompletado."}
{"instruction": "Qué es la normalización en bases de datos?", "response": "Es el proceso de organizar datos para reducir redundancia y mejorar la integridad, dividiendo tablas grandes en tablas más pequeñas relacionadas."}
{"instruction": "Diferencia entre SQL y NoSQL.", "response": "SQL usa bases de datos relacionales con esquemas estructurados. NoSQL abarca bases de datos no relacionales, flexibles (documentos, grafos, clave-valor)."}
{"instruction": "Qué es una carrera de datos (Race Condition)?", "response": "Ocurre en sistemas concurrentes cuando dos hilos acceden a un recurso compartido simultáneamente y el resultado depende del orden de ejecución."}
{"instruction": "Explica qué es un Deadlock.", "response": "Un deadlock es una situación donde dos o más procesos se bloquean mutuamente esperando recursos que el otro posee, impidiendo avanzar."}
{"instruction": "Qué es Big O(1)?", "response": "Indica tiempo constante. El algoritmo tarda lo mismo sin importar si la entrada tiene 10 o 1 millón de elementos."}
{"instruction": "Qué es Big O(log n)?", "response": "Indica tiempo logarítmico. Común en algoritmos que dividen el problema, como la búsqueda binaria. Es muy eficiente."}
{"instruction": "Qué es Big O(n^2)?", "response": "Indica tiempo cuadrático. Común en algoritmos con dos bucles anidados, como bubble sort. Se vuelve lento con entradas grandes."}
{"instruction": "Describe el patrón de diseño Singleton.", "response": "Singleton asegura que una clase tenga solo una instancia única y proporciona un punto de acceso global a ella."}
{"instruction": "Qué es la inyección de dependencias?", "response": "Es un patrón donde los objetos reciben sus dependencias desde fuera en lugar de crearlas ellos mismos, mejorando la modularidad y el testing."}
{"instruction": "Explica qué es un API REST.", "response": "Es una interfaz que permite la comunicación entre sistemas usando HTTP y principios como statelessness y recursos identificables por URL."}
{"instruction": "Qué es JSON?", "response": "JSON (JavaScript Object Notation) es un formato ligero de intercambio de datos, fácil de leer para humanos y máquinas."}
{"instruction": "Diferencia entre compilador e intérprete.", "response": "Un compilador traduce todo el código a lenguaje máquina antes de ejecutarlo. Un intérprete ejecuta el código línea por línea en tiempo real."}